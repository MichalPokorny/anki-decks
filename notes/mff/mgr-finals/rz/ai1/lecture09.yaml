deck: All::Magisterské státnice::Reprezentace znalostí::AI1::Přednáška 9
notes:
        # AI1 lecture09eng
        -
                uuid: 7e46b252-cedb-4f04-9aa8-9bea1746fd6c
                front: Co udělám s kvantifikátory když budeme dělat inferenci nad predikátovou logikou?
                back: Skolemizace (přidám funkční symboly)
        -
                uuid: c01a8c64-7ceb-457c-92b8-d14c3a1d9761
                front: Redukce predikátové logiky do výrokové logiky
                back: >
                        Vyrobím instance všech termů.
                        Z atomických sentencí udělám výrokové proměnné.
                        Z existenčních kvantifikátorů udělám novou konstantu.
                        Pro univerzální kvantifikátor substituuji všechny termy.
        -
                uuid: 777d9f11-a154-4c9d-b54b-e906343b4dcd
                front: Herbrandtova věta (krátce z AI1)
                back: >
                        Jestli se něco dá dokázat v predikátové logice,
                        jde to dokázat z konečné podmnožiny výrokové konverze.
        -
                uuid: 697dc7f9-4284-4e95-b215-b129470542a3
                front: Liftovaný modus ponens a substituce
                markdown: false
                back: >
                        [$]p_1,\ldots,p_2,
                           q_1\wedge q_2\wedge\ldots\wedge q_n\rightarrow q
                           \Longrightarrow \mathrm{subst}(\Theta,q)[/$],
                        kde [$]\Theta[/$] je substituce že
                        [$]\mathrm{subst}(\Theta,p_i)=\mathrm{Subst}(\Theta,q_i)[/$]
                        <br>
                        Funguje na Hornovské klauzule.
        -
                uuid: 23ca99f1-2d6a-4686-bbe1-5444e9fe03a1
                front: Hledání MGU (most general unifier), algoritmus
                back: >
                        Existuje právě jedna (až na přejmenování proměnných).<br><br>

                        Vstupy: x, y a zatím vybudovaná substituce.
                        x i y jsou proměnná, konstanta, seznam nebo term.<br><br>

                        Jestli jsou x=y, vrať.<br>
                        Jsou-li jedno z toho proměnné, udělej unifikaci proměnných.<br>
                        Jsou-li oba compoundy, musí mít stejné operace a unifikuj seznamy.<br>
                        Jsou-li oba seznamy, unifikuj postupně od začátku.<br><br>

                        Unifikace proměnné: jestli je do proměnné něco dosazené, dosaď to.
                        Zkontroluj, že dosazení můžu udělat (například ne třeba [$]x[/$] a [$]f(x)[/$]).<br>

                        Standartně z kontrolování proměnných vyjde kvadratická složitost. Ale jde to i lineárně?
        -
                uuid: e2b57811-bb9b-433a-8290-01fa63da49fd
                front: Forward-chaining algoritmus v FOL s Horn-klauzulemi, nevýhody
                back: >
                        Pro každou klauzuli v KB, ve které přejmenuju proměnné aby byly různé od mých:
                        pokud se to dá zunifikovat s něčím co už je v KB a konsekvent není přejmenování něčeho co už máme:
                        přidej to do KB. jestli odvodím hledanou věc, vrať že to jde přidat.<br>

                        Problém: [$]R(x) \\longrightarrow R(S(x))[/$] odvodí nekonečně mnoho faktů
        -
                uuid: 2580fca8-2aa3-4d3b-82c6-7bf1a7a18d14
                front: Složitost pattern-matchingu při hledání, jestli je splněné tělo klauzule
                back: >
                        NP-kompletní. Dá se na to převést barvení grafu
                        ([$]\\mathrm{diff}(\\mathrm{red},\\mathrm{green}), \\ldots, \\mathrm{diff}(\\mathrm{Wa},\\mathrm{Nt}) \\wedge \\mathrm{diff}(\\mathrm{Nt},\\mathrm{Sf}) \\wedge \\ldots \\Rightarrow \\mathrm{Colorable}[/$])
        -
                uuid: d7c74937-dfcd-45fa-9034-16a6c8710d78
                front: Heuristiky k pattern-matchingu v FOL
                back: >
                        <ul>
                        <li> *Indexuj podle predikátu*
                        <li>
                        [$$]\\mathrm{missile}(X) \\wedge \\mathrm{owns}(\\mathrm{nono},X) \\Rightarrow \\mathrm{sells}(\\mathrm{west},X,\\mathrm{nono})[/$$]
                        <br>
                        Matchovat nejdřív rakety, nebo co vlastní Nono? To čeho je míň (first-fail).
                        <li> Použij při inferenci pravidlo *jenom když se od jeho
                        posledního použití našel nový fakt* unifikovatelný
                        s něčím v těle.
                        </ul>
        -
                uuid: d64e682c-d2d1-48c8-890f-c6b55000394b
                topic: Rete algoritmus
                front: Na jaké formy KB se používá?
                back: Horn-SAT v FOL
        -
                uuid: 0527ffb0-7f61-454a-922e-e17fe12edaf1
                topic: Rete algoritmus
                front: Co dělá?
                back: >
                        Preprocesuj pravidla tak, abys rychleji uměl vyhledat,
                        které pravidlo znova odpálit až odvodíš nový fakt.
        -
                uuid: 353e6652-6f25-4f9d-9fde-dbb90b762d78
                front: Backward chaining v first-order Horn-SAT - algoritmus
                back: >
                        Query: seznam konjunkci co hledame v KB.
                        Substituce: nejdriv prazdna.<br>

                        Jestli nemám goaly: vrať nalezenou substituci.<br>

                        Aplikuj substituci na prvni cil [$]g_1[/$], a rozsir ji.<br>
                        Najdi nejake pravidlo, jehoz hlava jde zunifikovat s [$]g_1[/$].<br>
                        Přídej mezi cíle jeho tělo, zkomponuj substituce, rekurze.
        -
                uuid: ee3bd8a2-816b-4cc6-9fba-1f60c563d9f0
                front: Prostorová složitost FOL-BackwardChain-ASK, kompletnost
                back: >
                        Použij DFS na vyhledání všech řešení.
                        Lineární prostor vzhledem k délce důkazu.
                        Algoritmus není úplný.
        -
                uuid: 91172c55-d558-484d-87d7-f0fdd67a7e19
                front: Co je potřeba přidat do first-order logické rezoluce aby byla kompletní?
                back: >
                        <ul>
                        <li> Unifikace.
                        <li> Rozšířit na víc literálů.
                        <li> *Faktorizování* (na odebrání redundantních literálů - tj. těch co se dají zunifikovat).
                        </ul>
                        Je to pak sound & complete.
        -
                uuid: f9fb23bd-7d34-405d-954f-de5bfe06cd59
                front: Strategie pro rezoluci v FOL
                back: >
                        <ul>
                        <li> *Jednotková propagace*: preferujeme pokud jde udělat.
                        (Pro Hornovské klauzule je kompletní.)
                        <li> Podpůrná množina (*support set*): sada klauzulí
                        že jedna klauzule pro rezoluci je vždy z téhle množiny
                        a rezolvovanou klauzuli tam přidám.
                        Na začátku to obsahuje jenom negovaný query.
                        <li> *Input resolution*: (nekompletní): každý rezoluční krok
                        obsahuje aspoň jednu klauzuli ze vstupu.
                        <li> *Subsumpce*: nepřidávej redundantní klauzule do KB
                        </ul>
