# Reprezentace znalosti
deck: Magisterské státnice::Reprezentace znalostí
notes:
        # VPL01
        -
                uuid: dbb93f47-fe5c-4246-b2a8-fa5e09d2641e
                front: De Morganovy zákony
                back: >
                        [$]\\neg (p\\vee q)\\ekv \\neg p \\wedge \\neg q[/$],
                        [$]\\neg (p\\wedge q)\\ekv \\neg p \\vee \\neg q[/$]
        -
                uuid: a0e05572-826d-48dc-a83c-eee6c47f1da0
                front: Korektnost dokazovacího systému
                back: >
                        Každé dokazatelné tvrzení je pravdivé.
        -
                uuid: f30ff920-05b4-4398-a1ac-be85830b70ff
                front: Úplnost dokazovacího systému
                back: >
                        Každé pravdivé tvrzení je dokazatelé.
        -
                uuid: 15be3bd4-cd02-4e59-a111-af17faab4d7b
                front: Úplné a korektní dokazovací systémy
                back: >
                        Existují pro predikátovou logiku 1. řádu. Pro vyšší řády to neplatí.
        -
                uuid: d76da0c4-15d6-44e4-9432-a6e77dd763fd
                front: Jazyk 2. řádu přidává...
                back: proměné pro množiny individuí, i relace a funkce
        -
                uuid: f392c07a-37bd-4f9e-a895-1dc8227a15b7
                front: Berryho paradox
                back: "Nejmenší přirozené číslo, které nelze definovat méně než 40 slovy."
                include_reverse: true
        -
                uuid: fc297794-9a0b-49ba-b1d4-93fda7465e2a
                front: Vlastní třída
                back: >
                        Třída, která není množina (např. [$]\\{x | x = x\\}[/$])
        -
                uuid: 07d6859d-a95b-4598-8d91-a597fd855f10
                front: Uspořádaná dvojice a n-tice pomocí temna
                back: >
                        [$] (x,y)=\\{x,\\{x,y\\}\\}[/$], [$] (x,y,...,a,b)=( (x,y,...,a),b)[/$]
        -
                uuid: 142e01db-324e-4c11-80d5-455b0ffa5db6
                front: Extenze prvku v relaci
                back: >
                        [$]R[x] := \\{y | (x,y)\\in R\\}[/$]
        -
                uuid: 7201551b-4689-4d4c-9a5f-105f8d1ef0e1
                front: Restrikce relace na množinu
                back: >
                        [$]R \\uparrow z := \\{(x,y)\\in R | x\\in z\\}[/$]
        -
                uuid: fba2d766-3d01-4c2d-bcfc-235380c87129
                front: Složení relací
                back: >
                        [$]R \\circ S := \\{(x,z) | \\e y: (x,y)\\in R \\wedge (y,z)\\in S\\}[/$]
        -
                uuid: 87b2a8d7-7d7a-414d-9c5d-6d9f3f8e76aa
                front: Co je to ekvivalence?
                back: Relace, co je reflexivní, tranzitivní a symetrická.
        -
                uuid: 841205f1-80ed-42bb-a828-65022a2be1ab
                front: Značení - faktorizace množiny podle ekvivalence
                back: >
                        [$]X/R[/$]
        -
                uuid: cc67c5d5-eaf9-4bd5-8808-98555ba65f16
                front: Částečné uspořádaní - co to je?
                back: Relace, co je reflexivní, tranzitivní a antisymetrická.
        -
                uuid: 03be83bc-1276-432d-945c-16ff4459ba53
                front: Totální/lineární uspořádaní - co to je?
                back: >
                        Relace, co je reflexivní, tranzitivní a antisymetrická -- a navíc dichotomní (buď [$]x\\leq y[/$], nebo [$]y\\leq x[/$])
        -
                uuid: 121e98af-2fa4-4424-89db-a35176fe929b
                front: Dobré uspořádaní - co to je?
                back: >
                        Lineární uspořádání, ve kterém každá neprázdná množina obsahuje nejmenší prvek.
        -
                uuid: a70d9d08-6b88-4d9c-b376-3c8af7c41a98
                front: Husté uspořádaní - co to je?
                back: >
                        [$]x<y\\rightarrow\\e z(x<z\\wedge z<y)[/$]
        -
                uuid: dc27025f-a9b3-4b08-8c5e-0c9aa33a8409
                front: Surjektivní funkce (na [$]Y[/$])
                back: >
                        [$]rng(f)=Y[/$]

        -
                uuid: 2c22092b-1786-4976-b848-c6ec6d669c5a
                front: Injektivní funkce (prostá)
                back: >
                        Různé prvky mají různé obrazy
        -
                uuid: 2461213c-5a4d-46f8-9718-360ffcc300cc
                front: Definice - bijekce [$]X[/$] a [$]Y[/$]
                back: >
                        Prostá, definovaná na [$]X[/$], a na [$]Y[/$]
        -
                uuid: f44a1ee7-9fd9-4e13-a3e7-aa0d51b83684
                front: Notace - obraz množiny přes funkci
                back: >
                        [$]f[A][/$]
        -
                uuid: 3558d4ff-4be4-4135-9230-9c6f0b0d5ca6
                front: Složení funkcí
                back: >
                        [$] (f\\circ g)(x)=g(f(x)) [/$]
        -
                uuid: 5387df4e-9ea2-44e8-9e46-78893d356209
                front: Notace - všechny funkce z [$]X[/$] do [$]Y[/$]
                back: >
                        [$]\\_^X Y[/$]
        -
                uuid: 6191b09b-5e12-46b2-afa5-a8f60ab1ea8b
                front: Temno - přirozená čísla
                back: >
                        [$]0 = \\emptyset, 1 = \\{\\emptyset\\}, 2 = \\{0,1\\}, 3 = \\{0,1,2\\}, \\ldots[/$]
                        Nejmenší množina obsahující [$]\\emptyset[/$] a uzavřená na [$]S(x):=x\\cup\\{x\\}[/$]
        -
                uuid: 64a22917-7908-4fd9-a69a-c32e48aefd6c
                front: Temno - celá čísla
                back: >
                        [$] (\\N\\times\\N)/\\sim, (a,b)\\sim(c,d) := (a+c)=(b+d)[/$]
        -
                uuid: 99cd93eb-8c5b-47c5-b80d-792c2228814a
                front: Temno - racionální čísla
                back: >
                        [$]Q=(\\Z\\times(\\Z\\setminus\\{0\\}))/\\sim; \\sim:=(a,b)\\sim(c,d) :=: a\\cdot d = b\\cdot c[/$]
        -
                uuid: 7da62bd3-8a22-4aac-a45e-afd2fa97e1ef
                front: Temno - reálná čísla
                back: >
                        Množina řezů reálných čísel (netrivální, dolů uzavřené podmnožiny Q bez největšího prvku).
                        Uzavřenost dolů: [$]y<x\\in A\\rightarrow y\\in A[/$]
        -
                uuid: 8aa0f5d0-d6ab-4766-a4e1-4f3e32054ad0
                front: Temno - subvalence/stejná nebo menší velikost
                back: x je subvalentní y, když existuje prostá funkce z x do y
        -
                uuid: 371d6d55-64fa-43dd-9b59-92f75469f0bc
                front: Temno - stejná velikost
                back: Když existuje prostá funkce
        -
                uuid: 2a82ebde-66ca-4e93-8362-e3102d5460ec
                front: Cantorova věta a důkaz
                back: >
                        [$]x \\prec P(x)[/$] pro každou množinu [$]x[/$]

                        Důkaz: [$]f(y)=\\{y\\}[/$], je prostá funkce [$]f:x\\rightarrow P(x)[/$], tedy [$]x\\preceq P(x)[/$].

                        Ať pro spor je [$]g:P(x)\\rightarrow x[/$] prostá.
                        Definuj [$]y=\\{g(z) : z\\subseteq x \\wedge g(z)\\notin z\\}[/$].
                        Potom [$]g(y)\\in y\\ekv g(y)\\notin y[/$], spor.
        -
                uuid: c5a75596-b062-4fac-a1cc-7b7e914eccbc
                front: Funkce nulárních funkcí
                back: Ztotožněné s konstantami
        -
                uuid: cbf4ae9d-325d-4469-b4d5-08dd71a9d1b7
                front: Temno - strom, větev
                back: >
                        Množina s částečným uspořádáním, co má jediný nejmenší prvek (kořen) a množina předků libovolného prvku je dobře uspořádaná. Větev: maximální lineárně uspořádaná podmnožina.
        -
                uuid: 9857fa6b-b11e-4a04-907a-c5190219a9f6
                front: Königovo lemma a důkaz
                back: >
                        Každý nekonečný, konečně se větvící strom obsahuje nekonečnou větev.

                        Důkaz: Postupně vybírej potomky s nekonečným podstromem.
        # VPL02
        -
                uuid: b28d8d3b-9f0d-47d8-b456-edce8cc4f7fd
                front: Jazyk výrokové logiky
                back: >
                        Neprázdná množina prvovýroků, nejvýše spočetná: [$]P[/$]

                        Symboly: výrokové proměnné, spojky [$]\\neg \\vee \\wedge \\ekv \\rightarrow[/$], závorky

                        Logické proměnné a závorky: logické symboly, výrokové proměnné: mimologické problémy

                        Zkratky: [$]T:=(p\\vee\\neg p), \\perp:=(p\\wedge\\neg p)[/$] kde [$]p\\in P[/$] je pevný prvovýrok
        -
                uuid: dde0c382-a21c-4b8f-aef9-f8003cd6ddbc
                topic: Výroková logika
                front: Definice výrokové formule (výroku)
                back: Konečnou indukcí ze spojek, prvovýroků
        -
                uuid: b6688c17-2ecb-4a2a-a7a3-f9cd341f9ade
                topic: Výroková logika
                front: Notace - množina výrokových formulí nad množinou prvovýroků
                back: >
                        [$]VF_P[/$]
        -
                uuid: 36e19f36-84bc-4e96-b5d0-b2d41c85cb8b
                topic: Výroková logika
                front: >
                        Notace - výrokové proměnné ve formuli [$]\\varphi[/$]
                back: >
                        [$]var(\\varphi)[/$]
        -
                uuid: 211f7d08-34ae-48b5-afad-ec3d461d0e2a
                topic: Výroková logika
                front: Jak je daná sémantika logických spojek?
                back: Tabulkami
        -
                uuid: a95aa0a7-b43b-4c31-bdd4-541ffb2fbedc
                topic: Výroková logika
                front: Notace a definice - hodnota výroku při ohodnocení
                back: >
                        [$]\\overline{v}(\\varphi)[/$] při ohodnocení [$]v:P\\rightarrow\\{0,1\\}[/$] dána induktivně po spojkách.
                        Hodnota výroku záleží jenom na ohodnocení jeho proměnných (indukcí).
        -
                uuid: f8ecda2e-b187-4d77-94f4-d080c80bd066
                topic: Výroková logika
                front: Notace a definice - výrok platí při ohodnocení
                back: >
                        [$]v\\vDash \\varphi[/$], to když [$]\\overline{v}(\\varphi)=1[/$]
        -
                uuid: 78f1427c-c059-49ae-953d-71446b03a327
                topic: Výroková logika
                front: Notace a definice - výrok (logicky) platí, je tautologie
                back: >
                        [$]\\vDash \\varphi[/$], to když [$]\\a v: \\overline{v}(\\varphi)=1[/$];
                        obdobně lživý (sporný), nezávislý, splnitelný
        -
                uuid: 330383ff-d803-4471-804d-29a1308db645
                topic: Výroková logika
                front: Notace a definice - výroky jsou (logicky) ekvivalentní
                back: >
                        [$]\\varphi\\sim\\psi[/$]: [$]\\a v: \\overline{v}(\\varphi)=\\overline{v}(\\psi)[/$],
                        tj. [$]\\varphi\\ekv\\psi[/$] je pravdivý výrok
        -
                uuid: 1cae8dc0-b567-4bf7-92a0-099cb5477b4b
                topic: Výroková logika
                front: Notace a definice - modely
                back: >
                        Model: ohodnocení z [$]{}^P 2[/$].<br>
                        Třída modelů: [$]M(P)={}^P 2[/$]
        -
                uuid: afe80311-06a8-49fe-81a8-16429eb3622b
                topic: Výroková logika
                front: Peirceova spojka
                back: NOR ([$]p\\downarrow q[/$])
                include_reverse: true
        -
                uuid: fc9604da-8035-4f13-9bcf-728abf307d82
                topic: Výroková logika
                front: Shefferova spojka
                back: NAND ([$]p\\uparrow q[/$])
                include_reverse: true
        -
                uuid: f4c534be-7a2f-466f-9b40-17043533fb86
                topic: Výroková logika
                front: CNF
                back: Konjunkce klauzulí
        -
                uuid: 73a7e68a-d783-4ff5-afc8-022ec040f71c
                topic: Výroková logika
                front: DNF
                back: Disjunkce elementárních konjunkcí
        -
                uuid: 016aafc4-9d5c-47ca-af68-44e724632c2d
                topic: Výroková logika
                front: Kdy je výrok v CNF pravdivý?
                back: Každá klauzule obsahuje dvojici opačných literálů
        -
                uuid: 2d4b0844-a823-4115-9083-b4b07aa980ef
                topic: Výroková logika
                front: Kdy je výrok v DNF splnitelný?
                back: Aspoň jedna elementární konjunkce neobsahuje dvojici opačných literálů
        -
                uuid: 578417e1-fd32-482f-bd3c-47c6ff9e8927
                topic: Výroková logika
                front: Reprezentace množiny modelů pomocí DNF, CNF
                back: >
                        [$]M_P(\\bigvee_{v\\in K}\\bigwedge_{p\\in P}p^{v(p)})=K=M^P(\\bigwedge_{v\\in\\overline{K}}\\bigvee_{p\\in P}\\overline{p^{v(p)}})[/$]
        -
                uuid: 969de64f-db8b-4b61-9401-b4bfa3d07211
                topic: Výroková logika
                front: Postup pro převod na CNF/DNF
                back: >
                        1. [$] (\\varphi\\imp\\psi)\\sim(\\neg\\varphi\\vee\\psi), (\\varphi\\ekv\\psi)\\sim((\\neg\\varphi\\vee\\psi)\\wedge(\\neg\\psi\\vee\\varphi)[/$]

                        2. [$]\\neg\\neg\\varphi\\sim\\varphi[/$], [$]\\neg(\\varphi\\wedge\\psi)\\sim(\\neg\\varphi\\vee\\neg\\psi)[/$], [$]\\neg(\\varphi\\vee\\psi)\\sim(\\neg\\varphi\\wedge\\neg\\phi)[/$]

                        3. [$] (\\varphi\\vee(\\psi\\wedge\\chi))\\sim((\\phi\\wedge\\chi)\\vee\\varphi)\\sim((\\varphi\\vee\\psi)\\wedge(\\varphi\\vee\\chi)) [/$]

                        3'. [$] (\\varphi\\wedge(\\psi\\vee\\chi))\\sim((\\phi\\vee\\chi)\\wedge\\varphi)\\sim((\\varphi\\wedge\\psi)\\vee(\\varphi\\wedge\\chi)) [/$]
        -
                uuid: 550a4ee9-619d-4af7-bcf1-054e26bdb484
                topic: Výroková logika
                front: Co udělá ve výroku znegování literálů a náhrada [$]\\wedge\\ekv\\vee[/$]?
                back: >
                        [$]\\neg\\varphi\\sim\\varphi^{\\*}[/$]
        -
                uuid: d57f2e4c-405d-4c6d-8f6d-15de403f964b
                front: Jak řešit 2-SAT?
                back: >
                        Rozklad na silně souvislé komponenty (DFS),
                        od konce naplňuj implikační graf jedničkami
        -
                uuid: f4a4fe05-e63c-4178-8fd1-ffeaa8cd30bf
                topic: Výroková logika
                front: Hornova klauzule v VL
                back: >
                        Klauzule: [$] (\\neg a \\vee \\neg b \\vee \\ldots \\vee q) \\sim (a \\wedge b \\wedge \\ldots)\\rightarrow q[/$]
                        Obsahuje nejvýše jeden pozitivní literál
        -
                uuid: ae7be4b1-3e29-4b48-aa2b-881d2376b360
                front: Horn-SAT algoritmus ve VL
                back: >
                        Pokud obsahuje výrok dvojici jednotkových klauzulí co jsou obrácené literály, není splnitelný.

                        Odeber jednotkovou klauzuli, nastav ji na 1, odeber [$]\\overline{l}[/$] ze všech klauzulí a ostraň klauzule co obsahují literál [$]l[/$] (jednotková propagace).

                        Neobsahuje-li jednotkovou klauzuli, je splnitelný nastavením všeho ostatního na 0.
        -
                uuid: 6dc7d6e7-6b0e-4c75-9d76-aacbc074a8cc
                topic: Výroková logika
                front: Teorie, model teorie
                back: >
                        Množina výroků, kterým říkáme axiomy. Model teorie je
                        ohodnocení ve kterém teorie platí. Konečná teorie jde
                        nahradit konjunkcí axiomů.
        # VPL03
        -
                uuid: 55dd42d4-a5aa-4115-9ef2-c9b02cd48f5a
                topic: Výroková logika
                front: Důsledek výrokové teorie - značení, definice
                back: >
                        [$]\\Theta^{\\mathbb{P}}(T)[/$] je množina pravdivých výroků:
                        <br>
                        [$$]\\{\\varphi\\in VF_{\\mathbb{P} } | T\\vDash \\varphi\\}[/$$]
        -
                uuid: ee08dd5a-636f-438c-9493-4fdad59f4e94
                topic: Výroková logika
                front: Výrokové teorie a uzavřenost
                back: >
                        [$]T\\subseteq \\Theta^{\\mathbb{P} }(T) = \\Theta^{\\mathbb{P} }(\\Theta^{\\mathbb{P} }(T))[/$]<br>

                        Když [$]T\\subseteq T'[/$], tak [$]\\Theta^{\\mathbb{P} }(T)\\subseteq \\Theta^{\\mathbb{P} }(T')[/$]
        -
                uuid: eb3e8359-a566-418d-b318-9978b71660cb
                front: Kdy je [$]\\varphi\\in\\Theta^{\\mathbb{P} }(\\{\\varphi_1,\\varphi_2,\\ldots\\})[/$]?
                back: >
                        Právě když
                        [$]\\vDash(\\varphi_1\\wedge\\ldots\\wedge\\varphi_n)\\rightarrow\\varphi[/$]
        -
                uuid: 2e159e6a-d88a-4fd5-bb91-672b58bf1316
                topic: Výroková logika
                front: Kdy je teorie sporná, bezesporná?
                back: Když v ní platí [$]\\perp[/$], jinak splnitelná/bezesporná.
        -
                uuid: 1fefd1f4-381f-4be6-8d7e-987d6047d26d
                topic: Výroková logika
                front: Kdy je teorie kompletní, v závislosti na výrocích?
                back: Když v ní není žádný nezávislý výrok.
        -
                uuid: 538cee1e-0347-4653-866a-61e1e8c05890
                topic: Výroková logika
                front: Kdy je [$]T[/$] nad [$]P[/$] extenze teorie [$]T'[/$] nad [$]P'[/$]? Jednoduchá extenze? Konzervativní? (V řeči důsledků teorie.)
                back: >
                        Když [$]P'\\subseteq P[/$] a [$]\\Theta^{P'}(T')\\subseteq \\Theta^P(T)[/$]<br>

                        Jednoduchá: [$]P=P'[/$]

                        Konzervativní: [$]\\Theta^{P'}(T')=\\Theta^{P}(T)\\cap VF_{P'}[/$]
        -
                uuid: c770a38b-29a2-4a92-a90d-abb595d0e825
                front: Ekvivalentnost teorií a extenze
                back: >
                        Teorie jsou ekvivalentní, právě když jsou navzájem extenze.
        -
                uuid: 36857dca-668a-422b-aa0d-cb852bf6c26d
                front: Bezespornost, kompletnost, extenze, ekvivalentnost a modely
                back: >
                        Bezespornost: má model<br>
                        Kompletnost: má jediný model<br>
                        Extenze [$]T'[/$]: [$]M^{P}(T)\\subseteq M^P(T')[/$]<br>
                        Ekvivalentní: stejné modely
        -
                uuid: d8d5d31a-a11b-45e8-8b38-3219cf2696da
                front: Algebra výroků, jaký typ algebry to je
                back: >
                        [$]AV^P(T)=<VF_P/\\sim_T, \\neg, \\wedge, \\vee, \\perp, T>[/$]:
                                algebra výroků vzhledem k [$]T[/$]<br>

                        Rozdělené výroky podle toho jestli jsou v teorii ekvivalentní.
                        Zadefinováno podle reprezentantů.<br>

                        Je to Booleova algebra izomorfní potenční algebře [$]P(M(T))[/$].
        -
                uuid: 6f4868a0-2045-4e90-9ccb-e237f82bd3f2
                front: Kolik je neekvivalentních výroků nad [$]P[/$]?
                back: >
                        [$]2^{2^n}[/$], kde [$]n=|P|[/$]
        -
                uuid: 03f49979-0d87-498a-967f-d563eb83f167
                front: Kolik je neekvivalentních výroků nad [$]P[/$] pravdivých(lživých) v teorii [$]T[/$]?
                back: >
                        [$]2^{2^n - m}[/$], kde [$]n=|P|[/$], [$]m=|M^{P}(T)|[/$]
        -
                uuid: cd79a445-2b3f-46c5-af20-f688d39f5a76
                front: Kolik je neekvivalentních výroků nad [$]P[/$] nezávislých na teorii [$]T[/$]?
                back: >
                        [$]2^{2^n} - 2 \\cdot 2^{2^n-m}[/$]
        -
                uuid: c138f10e-9922-4786-a668-e7affab36529
                front: Kolik je neekvivalentních jednoduchých extenzí teorie [$]T[/$]?
                back: >
                        [$]2^m[/$], kde [$]m=|M^P(T)|[/$]
        -
                uuid: c55141d4-8b57-42fa-80e5-8da3bdcd3f81
                front: Kolik je neekvivalentních kompletních jednoduchých extenzí teorie [$]T[/$]?
                back: >
                        [$]m[/$], kde [$]m=|M^P(T)|[/$]
        -
                uuid: 847e2756-23c3-4000-b718-466407a716f9
                front: Kolik je [$]T[/$]-neekvivalentních výroků nad [$]P[/$]?
                back: >
                        [$]2^m[/$], kde [$]m=|M^P(T)|[/$]
        -
                uuid: 8bd25630-4c07-4715-b3d6-ddbbe6646c8d
                topic: Výroková logika
                front: Kolik je [$]T[/$]-neekvivalentních výroků co jsou v [$]T[/$] pravdivé(lživé)?
                back: 1
        -
                uuid: 17ac32d5-2a7d-47a2-8813-be73dd86c2fe
                topic: Výroková logika
                front: Kolik je T-neekvivalentních výroků nad [$]P[/$] nezávislých v [$]T[/$]?
                back: >
                        [$]2^m-2[/$], kde [$]m[/$] je počet modelů [$]T[/$]
        -
                uuid: a83fa4e0-d8d8-4610-ac30-43f61b16fe0e
                front: Značení - [$]\\varphi[/$] je dokazatelná z [$]T[/$]?
                back: >
                        [$]T\\vdash\\varphi[/$]
        -
                uuid: 4d36b776-53d6-4de6-9296-8a8b2d7796c8
                topic: Výroková logika
                front: Tablo metoda - předpoklady
                back: >
                        Jazyk je pevný a nejvýše spočetný, tedy taky nejvýše spočetné teorie.
        -
                uuid: 59196e8c-7002-43d3-b792-8d03c3b10945
                topic: Výroková logika
                front: Tablo metody - neformálně, co to je tablo, jak vypadá důkaz, jak bude vypadat protipříklad
                back: >
                        Tablo je binární značkovaný strom co reprezentuje hledání protipříkladu.<br>
                        <br>
                        Formule má důkaz, pokud každá větev tabla selže, v tom případě bude (systematické) tablo konečné.
                        <br>
                        Pokud existuje protipříklad, bude v tablu větev co ho poskytne; možná nekonečná.
        -
                uuid: db2135ef-5703-46a3-8800-a8f8e2766fdc
                topic: Výroková logika
                front: Atomická tabla, konečná tabla.
                back: >
                        Rozvine nějakou formuli, co je true/false, na možnosti, jak může být true/false.<br>

                        Konečné tablo vznikne připojením atomického tabla na konec větve jiného tabla.<br>

                        Tablo je posloupnost konečných tabel, co vznikají postupným výběrem.<br>
        -
                uuid: 929f4e0e-d098-466b-91f1-0c30f427ad65
                topic: Výroková logika
                front: Systematická tabla, tablo důkaz, vyvrácení
                back: >
                        Konvence: položka, podle které prodlužujeme, nebude opakovaná.<br>

                        Položka je v tablu redukovaná, když už je použitá jako kořen nějakého atomického tabla.
                        Větev je sporná, když obsahuje pro nějakou formuli T i F.
                        Dokončená, je, když je každá položka redukovaná.<br>

                        Dokončené tablo má všechny dokončené všechny větve. Sporné, když je každá větev sporná.<br>

                        Tablo důkaz: sporné tablo s kořenem [$]F\\varphi[/$], potom [$]\\vdash\\varphi[/$].<br>

                        Vyvrácení: sporné s kořenem [$]T\\varphi[/$], potom [$]\\vdash\\neg\\varphi[/$]
        -
                uuid: 2dbbe3d0-a408-4de5-b2a6-b263ea1c3fe9
                topic: Výroková logika
                front: Tablo z teorie
                back: >
                        Umožním krok "přidej axiom z teorie".
        # VPL04
        -
                uuid: 5938cb30-73ed-41cb-b42f-396a3dc80441
                topic: Výroková logika
                front: Systematická konstrukce tabla
                back: >
                        Dokud to jde, vezmi nejlevější položku [$]P[/$] v co nejmenší úrovni,
                        co není redukovaná na nějaké bezesporné větvi prochází
                        skrze [$]P[/$].<br>

                        Za každou bezespornou větev procházející skrz [$]P[/$]
                        přidej atomické tablo pro [$]P[/$].<br>

                        Ke každé bezesporné větvi přidej první [$]T\\varphi_n[/$]
                        atomické tablo pro výroky z teorie.
        -
                uuid: 94b787d4-4675-4b84-9fcd-c5fcaf06c5cc
                topic: Výroková logika
                front: Konečnost tablo důkazů
                back: >
                        Jestli je [$]\\tau=\\bigcup \\tau_i[/$] sporné,
                        tak je pro nějaké [$]n[/$] tablo [$]\\tau_n[/$]
                        sporné. Použijeme Konigovo lemma nad vrcholy stromu
                        [$]\\tau[/$] co nemají nad sebou spory.<br>
                        Proto jsou tablo důkazy konečné.
        -
                uuid: 5dd4f32d-c67d-4ec9-9be4-aa7228c5ba12
                topic: Výroková logika
                front: Korektnost tablo důkazů
                back: >
                        Když vemu nějaký model teorie, pak existuje v tablu
                        nějaká větev co se s ním shoduje. Postupuju indukcí.
                        <br>
                        [$]T\\vdash\\varphi \\Rightarrow T\\vDash\\varphi[/$]
        -
                uuid: aa9a0811-5102-4951-8fbf-3dd4d5da2f6a
                topic: Výroková logika
                front: Úplnost tablo metody
                back: >
                        Bezesporná větev v dokončeném tablu obsahuje protipříklad.
                        Model vyberu tak že dám [$]p=1[/$] pro [$]Tp[/$] co jsou
                        v tablu, jinak [$]0[/$]. (Důkaz indukcí podle struktury formule.)
                        <br>
                        [$]T\\vDash\\varphi\\Rightarrow T\\vdash\\varphi[/$]
                        Libovolné dokončené tablo co začne s [$]F\\varphi[/$] je sporné.
                        (Jinak z něho vykoukáme protipříkladový model.)
        -
                uuid: eccffdeb-c2aa-48b3-a849-08e4978c6f6a
                topic: Výroková logika
                front: Značení - Množina vět teorie
                back: >
                        [$]Thm^P(T)=\\{\\varphi\\in VF_P | T\\vdash\\varphi\\}[/$]
        -
                uuid: 5b415825-02e5-41f0-9f43-b2b4a120a6ac
                topic: Výroková logika
                front: Kdy je teorie sporná, v řeči důkazů?
                back: >
                        Když je v ní dokazatelný [$]\\perp[/$], jinak bezesporná
        -
                uuid: 62e6a8ed-08d2-45ed-851b-05d68fc93dd6
                topic: Výroková logika
                front: Kdy je teorie kompletní, v řeči důkazů?
                back: >
                        Když není sporná a pro každou formuli je dokazatelná nebo její opak.
        -
                uuid: 49196989-9bcb-4014-a61b-739b5a695834
                topic: Výroková logika
                front: Kdy je [$]T[/$] nad [$]P[/$] extenze teorie [$]T'[/$] nad [$]P'[/$] v řeči důkazů? Kdy je jednoduchá a konzervativní?
                back: >
                        Když [$]P'\\subseteq P[/$] a [$]Thm^{P'}(T')\\subseteq Thm^P(T)[/$].
                        Jednoduchá: [$]P=P'[/$],
                        konzervativní: [$]Thm^{P'}(T')=Thm^P(T)\\cap VF_{P'}[/$]
        -
                uuid: 2b7d1685-6255-415d-b748-8fa56cf28d64
                topic: Výroková logika
                front: Věta o kompaktnosti
                back: >
                        Teorie má model právě když každá její konečná část má model.<br>

                        Zleva doprava: OK. Zprava doleva: tablo důkaz sporu je konečný.<br>
        # VPL05
        -
                uuid: 9cd8aea3-f680-40ed-afe2-cceb82ac2e07
                topic: Výroková logika
                front: Hilbertovy axiomy a odv. pravidla
                back: >
                        1. [$]\\varphi\\rightarrow(\\psi\\rightarrow\\varphi)[/$]

                        2. [$] (\\alpha\\rightarrow(\\beta\\rightarrow\\gamma))\\rightarrow((\\alpha\\rightarrow\\beta)\\rightarrow(\\alpha\\rightarrow\\gamma))[/$]

                        3. [$] (\\neg\\alpha\\rightarrow\\neg\\beta)\\rightarrow(\\beta\\rightarrow\\alpha)[/$]

                        Odvozovací pravidlo: modus ponens ([$]\\alpha, \\alpha\\rightarrow\\beta[/$] ==> [$]\\beta[/$])
        -
                uuid: 14ccef71-7564-494a-84a2-13e59c0d9f66
                topic: Výroková logika
                front: Hilbertovy systémy - vlastnosti
                back: >
                        [$]T\\vdash_H \\varphi \\Rightarrow T\\vDash \\varphi[/$]

                        Taky je úplný. (Ale bez důkazu.)
        -
                uuid: 10560f57-6949-4cdb-9700-ed78c8c25908
                topic: Výroková logika
                front: Rezoluční metoda - množinová reprezentace
                back: >
                        Klauzule je konečná množina kladných nebo záporných literálů.
                        Formula je (i nekonečná) množina klauzulí.
                        (Částečné) hodnocení je libovolná konzistentní množina literálů.
        -
                uuid: 2e3c9cf5-50be-4bae-97e2-b50dc295c058
                topic: Výroková logika
                front: Rezoluční pravidlo
                back: >
                        Ať je [$]C_1[/$], [$]C_2[/$] klauzule, [$]l\\in C_1, \\overline{l}\\in C_2[/$] nějaký
                        literál v [$]l[/$].
                        Z [$]C_1[/$] a [$]C_2[/$] odvodím přes literál [$]l[/$] klauzuli [$]C[/$], zvanou [$]rezolventa[/$]:<br>

                        [$$]C=(C_1\\setminus\\{l\\}) \\vee (C_2\\setminus\\{l\\})[/$$]<br>

                        Je korektní.
        -
                uuid: 09391262-d1b6-42c1-bb9d-3cd9e055173b
                topic: Výroková logika
                front: Rezoluční důkaz, rezoluční strom, uzávěr
                back: >
                        Konečná posloupnost kde každá klauzule je rezoluce předchozích klauzulí a začátek je teorie.
                        Zamítnutí je rezoluční důkaz sporu.<br>
                        Jestli je věta rezolucí zamítnutelná, je nesplnitelná.<br>
                        Rezoluční strom: posloupnost rezolucí<br>
                        Uzávěr: všechno co jde resolvovat.
        -
                uuid: af0107b9-d3e9-4058-9b01-65bb2e900422
                topic: Výroková logika
                front: Rezoluce - splnitelnost formule a dosazení literálu
                back: >
                        [$]S[/$] je splnitelná právě když je splnitelná [$]S^{\\ell}[/$] nebo [$]S^{\\overline{\\ell} }[/$] (dosazení s unit propagation)
        -
                uuid: 00085e32-d2c3-4bc9-8e44-2e369dcc75db
                topic: Výroková logika
                front: Úplnost rezoluce
                back: >
                        Jestli je konečná teorie nesplnitelná, dá se rezolucí vyvrátit.<br>
                        Vezmu literál. Dle lemmatu není splnitelné ani dosazení true, ani false.
                        Dle indukčního předpokladu umím odvodit spor z [$]S^\\ell[/$] i z [$]S^{\\overline{\\ell} }[/$].<br>
                        Rezolucí kořenů ([$]\\{\\ell\\}[/$] a [$]\\{\\overline{\\ell}\\}[/$]) získáme spor.
        -
                uuid: 38974d87-11b0-4dfb-a831-28dc2ad9671f
                topic: Výroková logika
                front: Lineární důkaz
                back: >
                        Konečná posloupnost dvojic: jedna je boční klauzule (buď něco už dokázaného, nebo axiom).
                        Je to úplné a korektní.
                        Obzvlášť pro Hornovy klauzule. (Linear-input reslution)
        # VPL06
        -
                uuid: 69795a03-adcf-4807-a029-1e44b541f3aa
                topic: Predikátová logika
                front: Jazyk predikátové logiky
                back: >
                        Spočetně mnoho proměnných ([$]Var[/$])<br>
                        Funkční symboly včetně konstantních symbolů<br>
                        Relační symboly, potenciálně rovnost (speciální relační symbol) (nulární relační symboly můžou být výrokové proměnné)<br>
                        Kvantifikátory pro každou proměnnou<br>
                        Logické spojky<br>
                        Závorky
        -
                uuid: 975ca80f-6978-450c-9d7c-34aef9c01d61
                topic: Predikátová logika
                front: Jazyk predikátové logiky - logické symboly
                back: >
                        Proměnné, kvantifikátory, logické spojky, závorky
        -
                uuid: 3c41be43-70a0-4de3-a64f-ed2fbb2fbf33
                topic: Predikátová logika
                front: Jazyk predikátové logiky - mimologické symboly symboly
                back: >
                        Funkční a relační symboly (mimo rovnosti)
        -
                uuid: c9fc1b59-1345-492d-a0a5-062d717c2b49
                topic: Predikátová logika
                front: Jazyk predikátové logiky - signatura
                back: >
                        Dvojice disjunktních množin relačních, funkčních symbolů. Určuje všechny mimologické symboly.
                        Určuje jazyk, s uvedením jestli má rovnost.
        -
                uuid: 23b26383-4ffc-4304-aa1f-134a3f7b9ef8
                topic: Predikátová logika
                front: Jazyk predikátové logiky - term
                back: >
                        Proměnná nebo konstantní symbol; aplikace funkce; konečně rekurzivně.<br>

                        Konstantní term: bez proměnných<br>

                        [$]Term_L[/$]<br>
        -
                uuid: fd065fa4-4615-4f4d-936b-ba6d9b69ae85
                topic: Predikátová logika
                front: Predikátová logika - atomická formule
                back: >
                        [$]AFm_L[/$]` aplikace relačního symbolu na termy.
        -
                uuid: ff8a816b-b627-4c3b-985b-da2c4f9915e5
                topic: Predikátová logika
                front: Predikátová logika - formule
                back: >
                        Atomická formule, pak indukce nad spojkami,
                        přidání kvantifikátorů; [$]Fm_L[/$]
        -
                uuid: 2f29cdd6-054d-419c-bbf7-a3f898096b66
                topic: Predikátová logika
                front: Vázaný, volný výskyt proměnné
                back: >
                        Je součást podformule co začíná [$] (\a x)[/$] nebo [$] (\e x)[/$].<br>
                        Volný výskyt je ten co není vázaný.
                        Proměnná může být volná i vázaná.
        -
                uuid: c15d88b8-3355-4d23-8863-10609edf0914
                topic: Predikátová logika
                front: Predikátová logika - otevřená formule
                back: Neobsahuje žádný kvantifikátor
        -
                uuid: 35fed406-e6dd-43f6-a992-498882898efe
                topic: Predikátová logika
                front: Predikátová logika - uzavřená formule (sentence)
                back: Všechny výskyty jsou vázané
        -
                uuid: f40b899d-6a4f-43db-b48c-add74adb0ba1
                topic: Predikátová logika
                front: Jaká formule je zároveň uzavřená a otevřená?
                back: >
                        Když má všechny termy konstantní.
        -
                uuid: c710c373-4324-456c-a932-1cf0c9ca586c
                topic: Predikátová logika
                front: Instance formule [$]\\varphi(x/t)[/$]
                back: >
                        Substituuji term [$]t[/$] za proměnnou [$]x[/$].
                        Term je substituovatelný za [$]x[/$], když
                        po současném nahrazení všech výskytů nevznikne
                        žádný vázaný výskyt žádné proměnné z [$]t[/$].
        -
                uuid: ccdfaa76-d9a5-4990-8376-c7420ddd5a10
                topic: Predikátová logika
                front: Varianta formule
                back: >
                        At je [$] (Qx)\\psi[/$] podformule v [$]\\varphi[/$]
                        a [$]y[/$] je promenna, co je substituoatelna za [$]x[/$] do
                        [$]\\psi[/$] a [$]y[/$] nema volny vyskyt v [$]\\psi[/$].<br>
                        Nahrazeni podformule [$] (Qx)\\phi[/$] za [$] (Qy)\\phi(x/y)[/$]
                        vznikne varianta formule [$]\\varphi[/$] v podformuli [$] (Qx)\\psi[/$].<br>
                        Postupnou aplikaci variant vznikne varianta.
        -
                uuid: 900d9315-ebb7-4d42-be1e-78a99547a9f7
                topic: Predikátová logika
                front: Struktura pro jazyk
                back: >
                        [$]L=<R,F>[/$] at je jazyk, [$]A[/$] neprazdna mnozina.
                        <br>
                        Realizace relacniho symbolu: relace. Realizace rovnosti: identita.
                        <br>
                        Podobne realizace funkci.
                        <br>
                        Struktura: trojice [$]\\mathcal{A}=<A,R^A,F^A>[/$] --
                        doména (univerzum) -- NEPRÁZDNÁ, realizace relací, realizace funkcí.
        -
                uuid: 206817a7-4702-4c97-a587-78cdb5606734
                topic: Predikátová logika
                front: Hodnota termu
                back: >
                        Ohodnocení proměnných v množině [$]A[/$]: [$]e:Var\\rightarrow A[/$].
                        Hodnota termu: rekurzivně definovaná [$]t^A[e][/$].
                        Hodnota termu záleží jenom na ohodnocení proměnných.
        -
                uuid: f5ae98b3-d8c7-4b34-ab70-85b8ef73b6e1
                topic: Predikátová logika
                front: Hodnota atomické formule
                back: >
                        Hodnota [$]H_{at}^{A}(\\varphi)[e][/$]: pro atomickou formuli ([$]=^A[/$] je [$]Id_A[/$]).
                        Když je [$]\\varphi[/$] sentence, hodnota nezáleží na ohodnocení.
        -
                uuid: 9c307f26-043d-4bb3-9ce3-32df21c68bc8
                topic: Predikátová logika
                front: Hodnota neatomické formule
                back: >
                        Použiju Booleovské funkce definované tabulkami.<br>
                        Nad strukturou: [$]H^A((\a x)\\varphi)[e] = \\min_{a\\in A}(H^A(\\varphi)[e(x/a)])[/$]
                        Záleží jenom na volných proměnných.
        -
                uuid: 559e0291-255d-448a-ae25-dbab2c2e58e2
                topic: Predikátová logika
                front: Značení - formule platí při ohodnocení ve struktuře
                back: >
                        [$]\\mathcal{A}\\vDash\\varphi[e][/$] (když [$]H^A(\\varphi)[e]=1[/$]).
        -
                uuid: 99164312-4f7a-4410-a65e-02616a49d4ad
                front: Platnost ve struktuře
                topic: Predikátová logika
                back: >
                        [$]\\mathcal{A}\\vDash\\varphi[/$] když platí pro každé ohodnocení.
                        Podobně lživá.
        -
                uuid: 74221bc3-313b-4e52-b416-41e7f436047e
                topic: Predikátová logika
                front: Teorie v predikátové logice
                back: >
                        Teorie je libovolná množina formulí (axiomů).<br>
                        Model je L-struktura ve které platí axiomy teorie.<br>
                        Třída modelů [$]M(T)[/$].
        # VPL07
        -
                uuid: 57180c0e-17da-4b23-bc7c-d4276feb2528
                topic: Predikátová logika
                front: Kdy jsou dvě struktury pro jazyk elementárně ekvivalentní?
                back: >
                        Když v nich platí stejné formule.
        -
                uuid: 7026775f-598b-4f44-a40f-bafe3377d3e3
                topic: Predikátová logika
                front: Kdy je teorie predikátové logiky kompletní?
                back: Když má až na elementární ekvivalenci jeden model.
        -
                uuid: f1ae363a-3beb-43be-9298-96d4462df6cc
                topic: Predikátová logika
                front: Sentence platí a modely její teorie
                back: >
                        [$]T,\\neg\\varphi[/$] nemá model právě když [$]T\\vDash\\varphi[/$]
        -
                uuid: 0ac76171-c4fc-4472-b630-a7cd346f8ac0
                topic: Predikátová logika
                front: Definice - podstruktura
                back: >
                        [$]\\mathcal{B}\\subseteq \\mathcal{A}[/$],
                        když:
                        <br>
                        [$]B\\subseteq A[/$],
                        <br>
                        [$]R^B=R^A\\cap B^{ar(R)}[/$],
                        [$]f^B=f^A\\cap B^{ar(f) + 1}[/$]
        -
                uuid: 3efd2fef-a40d-411c-a84f-bbe71ea136b7
                front: Definice - Doména podstruktury [$]\\mathcal{A}[/$], parcializace/restrikce struktury
                back: >
                        [$]C\\subseteq A[/$] je doména podstruktury [$]\\mathcal{A}[/$],
                        když je [$]C[/$] uzavřená na funkce struktury.
                        Tahle podstruktura je [$]\\mathcal{A}\\upharpoonright C[/$].
        -
                uuid: 2d37d192-8f2d-46d4-bd4b-51a708a8fd07
                front: Platnost otevřené formule a podstruktury
                back: Otevřená formule platí právě když platí ve všech podstrukturách
        -
                uuid: 6a88b8d7-febe-4035-98ef-c054a9bd9d38
                front: Podstruktury modelů otevřených teorií...
                back: ...jsou taky modely T.
        -
                uuid: 77f28e2a-8e8e-4947-861f-c764b65b1438
                front: Generovaná podstruktura
                back: >
                        Když je [$]B[/$] nejmenší podmnožina nosné množiny
                        co je uzavřená na všechny funkce, pak [$]\\mathcal{A}\\upharpoonright B[/$]
                        se značí taky [$]\\mathcal{A}< X >[/$] -- generovaná množinou X.
        -
                uuid: 653333bb-a0e5-484c-bcbb-c25d0fd6d2d4
                front: Redukty a expanze struktury
                back: Přidání nebo odebrání realizací
        -
                uuid: 0cc7f4cc-f083-47a1-8ebc-1cdba375bdae
                front: Věta o konstantách
                back: >
                        Když vemu formuli a nahradím volné proměnné novými
                        konstantami, je původní formule platná právě když
                        nahrazená.
        -
                uuid: c697f0ee-b254-4e54-8ab4-c6f631a9dd7c
                front: Teorie Booleových algeber
                back: >
                        [$]L=<-,\\wedge,\\vee,0,1>[/$] s rovností<br>

                        asociativita obou operátorů,
                        komutativita obou operátorů,
                        distributivita ([$]x\\wedge(y\\vee z)=(x\\wedge y)\\vee(x\\wedge z)[/$] a obráceně),
                        absorbce ([$]x\\wedge(x\\vee y)=x[/$] a obráceně),
                        komplementarita ([$]x\\vee(-x)=1, x\\wedge(-x)=0[/$]),
                        [$]0\\neq1[/$].

                        Až na isomorfismus jsou to právě [$]{}^n 2[/$].
        -
                uuid: 41c75c64-10f8-4496-86c0-2ee584532ba9
                front: Tablo metoda v PL
                back: >
                        Formule v položkách jsou uzavřené formule (bez volných proměnných).
                        Přidám atomická tabla pro kvantifikátory, za které přidávám konstantní termy.
                        Přidám spočetně mnoho "svědků" (pomocné konstantní symboly).
                        V dokončené větvi budou instance všech dosazení všech konstantních termů.
                        Jazyk musí být nejvýše spočetný.
        -
                uuid: e220d595-7e21-48b9-aafa-93603166311e
                front: Tablo metoda v PL - nová atomická tabla
                back: >
                        [$]T(\\a x)\\varphi(x)[/$]: dosaď konstantní term<br>

                        [$]F(\\a x)\\varphi(x)[/$]: dosaď NOVOU konstantu [$]F\\varphi(x/c)[/$]<br>

                        podobně pro [$]\\e[/$]
        # TODO: VPL08
        # TODO: VPL09
        # TODO: VPL10
        # TODO: VPL11
        # TODO: VPL12
        # TODO: VPL13
        # AI1 lecture08eng
        -
                uuid: 5a69d98e-5c28-4ab7-bd1b-f42a409e6d38
                front: Knowledge-based agents
                back: >
                        Form representations of a complex world. Use inference.
                        Use information and current observation to uncover
                        hidden aspects of the world, use them for action
                        selection.
        -
                uuid: aa2b3bf4-bb7b-4f1f-ad3c-e8f0c6e9745a
                front: Wumpus world
                back: >
                        Stench: next to wumpus<br>
                        Breeze: adjacent to pit<br>
                        On gold: glitter<br>
                        Bump when hitting a wall.<br>
                        Just one arrow.<br>
                        Killed wumpus screams, and it can be heard everywhere.<br>
                        <br>
                        +1000 points for exiting with gold.
                        -1000 for dying.
                        -1 per action.
                        -10 for using an arrow.
                        4x4 grid of rooms.
        -
                uuid: fa8c6a5d-7fd7-4a88-aca2-96ad891314d2
                front: World parameters
                back: >
                        Observable fully or partially?<br>
                        Deterministic? (action results are deterministic)<br>
                        Episodic? (is the ordering of actions important?)<br>
                        Static or dynamic?<br>
                        Discrete or continuous?<br>
                        Single-agent or multi-agent?
        -
                uuid: f22d1e32-4575-4f82-924d-002c086ccfa0
                front: Syntax and semantics
                back: >
                        Syntax: allowable sentences. <br>
                        Semantics: rules for determining truth in some model.
        -
                uuid: a40431e9-ff7c-4ef9-b332-bd03a09f473b
                front: Entailment, soundness, completeness
                back: >
                        [$]KB \\vdash \\alpha[/$].
                        Sound, if [$]\\vdash\\rightarrow\\vDash[/$].
                        Complete, if [$]\\vdash\\leftarrow\\vDash[/$].
        -
                uuid: 7d7eb23d-528e-4207-a492-cd6c2745e950
                front: Model checking vs. inference rules
                back: >
                        Model checking: enumerating a truth table (DPLL, local search)<br>
                        Inference rules: theorem proving by applying inference; resolution
        -
                uuid: 5d4a8625-7347-4bc4-83f6-203b796b3cb6
                front: DPLL - full name
                back: Davis, Putnam, Logemann, Loveland
        -
                uuid: 3349db11-6a76-43ce-9713-b60fa007d4d2
                front: DPLL - algoritmus
                back: >
                        Postupně buduj model.

                        Pokud všechny klauzule platí v modelu, vrať true.
                        Pokud některá neplatí, vrať false.

                        Najdi čistý symbol (co je jenom true nebo jenom false).
                        Jestli existuje, přidej do modelu a odeber všechny klauzule co ho obsahují.

                        Najdi jednotkovou klauzuli.
                        Jestli existuje, přidej ji do modelu a odeber.

                        Potom, vyzkoušej nastavení nějakého literálu na true nebo false.
        -
                uuid: 5c833a52-d98e-43d4-a6f7-28c02467087c
                front: WalkSAT - algoritmus, vlastnosti
                back: >
                        Hill climbing s random walk.

                        Minimalizuju počet konfliktních klauzulí.

                        Lokální krok je prohození hodnoty jedné proměnné.
                        Je korektní, ale není úplný.

                        S pravděpodobností [$]p[/$]: vyber náhodně nesplněnou klauzuli a flipni v ní náhodný literál.
                        Jinak: flipni v ní ten symbol, co maximalizuje počet splněných klauzulí.
        -
                uuid: 5bcba863-e602-4f36-980b-8eae27c89520
                front: Fázový přechod mezi náhodnými splnitelnými a nesplnitelnými formulemi v 3-SATu
                back: počet klauzulí / počet proměnných = 4.3
        -
                uuid: af330fd7-d530-4274-888f-a68c88dfc60d
                front: Rezoluční algoritmus, pro formuli
                back: >
                        Vyrob množinu odvozených klauzulí, dej tam negaci formule a KB.

                        Vyber všechny dvojice klauzulí a zkus rezoluci.
                        Když odvodíš prázdnou klauzuli, vrať že formule platí.
                        Když přestaneš odvozovat, vrať že to nemusí být splněné.
        -
                uuid: efd03dde-5859-4cdd-97df-ee4ba989c438
                front: Jakou formu mají ve výrokové logice Hornovské klauzule?
                back: >
                        Nejvýše jeden pozitivní literál v klauzuli.
        -
                uuid: ee26feb0-37d9-45a0-96a2-b2b1044f8084
                front: Forward-chaining - algoritmus, časová složitost
                back: >
                        Funguje na Hornovské klauzule.
                        Ze známých faktů odvodíme všechno, co můžeme.<br>

                        Pro každou klauzuli si budu držet počet zatím nesplněných
                        předpokladů. Když dosáhnu 0, tak odvodím-li hledaný důsledek,
                        vrátím 0, jinak přidám odvozený symbol do agendy.<br>

                        Je to úplný a korektní algoritmus pro Hornovy klauzule.
                        Má lineární složitost vzhledem k velikosti KB.
        # AI1 lecture09eng
        -
                uuid: 7e46b252-cedb-4f04-9aa8-9bea1746fd6c
                front: Co udělám s kvantifikátory když budeme dělat inferenci nad predikátovou logikou?
                back: Skolemizace (přidám funkční symboly)
        -
                uuid: c01a8c64-7ceb-457c-92b8-d14c3a1d9761
                front: Redukce predikátové logiky do výrokové logiky
                back: >
                        Vyrobím instance všech termů.
                        Z atomických sentencí udělám výrokové proměnné.
                        Z existenčních kvantifikátorů udělám novou konstantu.
                        Pro univerzální kvantifikátor substituuji všechny termy.
        -
                uuid: 777d9f11-a154-4c9d-b54b-e906343b4dcd
                front: Herbrandtova věta (krátce z AI1)
                back: >
                        Jestli se něco dá dokázat v predikátové logice,
                        jde to dokázat z konečné podmnožiny výrokové konverze.
        -
                uuid: 697dc7f9-4284-4e95-b215-b129470542a3
                front: Liftovaný modus ponens a substituce
                back: >
                        [$]p_1,\\ldots,p_2, q_1\\wedge q_2\\wedge\\ldots\\wedge q_n\\rightarrow q[/$] ==> [$]Subst(\\Theta,q)[/$],
                        kde [$]\\Theta[/$] je substituce ze [$]Subst(\\Theta,p_i)=Subst(\\Theta,q_i)[/$]<br>

                        Funguje na Hornovské klauzule.
        -
                uuid: 23ca99f1-2d6a-4686-bbe1-5444e9fe03a1
                front: Hledání MGU (most general unifier), algoritmus
                back: >
                        Existuje právě jedna (až na přejmenování proměnných).<br><br>

                        Vstupy: x, y a zatím vybudovaná substituce.
                        x i y jsou proměnná, konstanta, seznam nebo term.<br><br>

                        Jestli jsou x=y, vrať.<br>
                        Jsou-li jedno z toho proměnné, udělej unifikaci proměnných.<br>
                        Jsou-li oba compoundy, musí mít stejné operace a unifikuj seznamy.<br>
                        Jsou-li oba seznamy, unifikuj postupně od začátku.<br><br>

                        Unifikace proměnné: jestli je do proměnné něco dosazené, dosaď to.
                        Zkontroluj, že dosazení můžu udělat (například ne třeba [$]x[/$] a [$]f(x)[/$]).<br>

                        Standartně z kontrolování proměnných vyjde kvadratická složitost. Ale jde to i lineárně?
        -
                uuid: e2b57811-bb9b-433a-8290-01fa63da49fd
                front: Forward-chaining algoritmus v FOL s Horn-klauzulemi, nevýhody
                back: >
                        Pro každou klauzuli v KB, ve které přejmenuju proměnné aby byly různé od mých:
                        pokud se to dá zunifikovat s něčím co už je v KB a konsekvent není přejmenování něčeho co už máme:
                        přidej to do KB. jestli odvodím hledanou věc, vrať že to jde přidat.<br>

                        Problém: [$]R(x) \\longrightarrow R(S(x))[/$] odvodí nekonečně mnoho faktů
        -
                uuid: 2580fca8-2aa3-4d3b-82c6-7bf1a7a18d14
                front: Složitost pattern-matchingu při hledání, jestli je splněné tělo klauzule
                back: >
                        NP-kompletní. Dá se na to převést barvení grafu ([$]Diff(Red,Green), \\ldots, Diff(wa,nt) \\wedge Diff(nt,sf) \\wedge \\ldots \\Rightarrow Colorable[/$])
        -
                uuid: d7c74937-dfcd-45fa-9034-16a6c8710d78
                front: Heuristiky k pattern-matchingu v FOL
                back: >
                        Indexuj fakta podle jejich predikátu.<br>
                        [$$]Missile(x) \\wedge Owns(Nono,x) \\Rightarrow Sells(West,x,Nono)[/$$]
                        <br>
                        Budu hledat nejdřív rakety, nebo věci co vlastní Nono?
                        Najdi to čeho je míň (first-fail -- constrain satisfaction).
                        <br>
                        Používej při inferenci pravidlo jenom jestli jsme od jeho
                        posledního použití odvodili nějaký nový fakt, který
                        je v jeho těle. (Resp., co je unifikovatelný s něčím v těle.)
        -
                uuid: 0527ffb0-7f61-454a-922e-e17fe12edaf1
                front: Rete algoritmus
                back: >
                        Horn-SAT v FOL.
                        <br>
                        Preprocesuj pravidla tak, abys rychleji uměl vyhledat,
                        které pravidlo znova odpálit až odvodíš nový fakt.
        -
                uuid: 353e6652-6f25-4f9d-9fde-dbb90b762d78
                front: Backward chaining v FOL
                back: >
                        Query: seznam konjunkci co hledame v KB.
                        Substituce: nejdriv prazdna.<br>

                        Jestli nejsou goaly: vrat nalezenou substituci.<br>

                        Aplikuj substituci na prvni cil, a rozsir ji.<br>
                        Najdi nejake pravidlo, jehoz hlava jde zunifikovat s cilem.
                        Pokus se rekurzivne pridat mezi cile jeho telo, zkomponuj substituce.
        -
                uuid: ee3bd8a2-816b-4cc6-9fba-1f60c563d9f0
                front: Prostorová složitost FOL-BackwardChain-ASK, kompletnost
                back: >
                        Použij DFS na vyhledání všech řešení.
                        Lineární prostor vzhledem k délce důkazu.
                        Algoritmus není úplný.
        -
                uuid: 91172c55-d558-484d-87d7-f0fdd67a7e19
                front: Co je potřeba přidat do first-order logické rezoluce aby byla kompletní?
                back: >
                        Unifikace.
                        Rozšířit na víc literálů.
                        Faktorizování (na odebrání redundantních literálů - tj. těch co se dají zunifikovat).
                        Je to pak sound & complete.
        -
                uuid: f9fb23bd-7d34-405d-954f-de5bfe06cd59
                front: Strategie pro rezoluci v FOL
                back: >
                        Jednotková propagace: preferujeme ji pokud jde udělat.
                        (Pro Hornovské klauzule to je kompletní.)
                        <br>
                        Podpůrná množina (support set): sada klauzulí
                        že jedna klauzule pro rezoluci je vždy z téhle množiny
                        a rezolvovanou klauzuli tam přidám.
                        Na začátku to obsahuje jenom negovaný query.
                        <br>
                        Input resolution: (nekompletní): každý rezoluční krok
                        obsahuje aspoň jednu klauzuli ze vstupu.
                        <br>
                        Subsumpce: nepřidávej redundantní klauzule do KB
                        (co jsou implikované něčím jiným už)
        # AI2 lecture11
        -
                uuid: 6f2dc87d-6cd2-4f0f-af24-41f59c1bd1e7
                topic: Reinforcement learning
                front: Model
                back: >
                        Reward je soucast perceptu.
        -
                uuid: 27ace965-3b57-42cd-bad0-d408486e7765
                topic: Reinforcement learning
                front: Reflex agent
                back: >
                        Naučí se policy, která mapuje ze stavů do akcí.
        -
                uuid: c9942fb6-b315-4fc1-b894-20c330b2e456
                topic: Reinforcement learning
                front: Pasivní učení
                back: Učí se utility stavů, ale policy je zafixovaná.
        -
                uuid: fdf84e9e-a1e8-4685-a6e4-bd5023208f91
                topic: Reinforcement learning
                front: Aktivní učení
                back: Učí se utility stavů i policy, takže potřebuje i exploration
        -
                uuid: 7f9a9722-e639-4a62-a0c5-197829ce21c6
                front: Utility funkce, kterou se učí pasivní učení; model (jako nekonečná suma)
                back: >
                        [$]U^\\pi(s)=\\mathbb{E}[\\sum_{t=0\\ldots\\infty} \\gamma^t \\cdot R(s_t)] [/$]
        -
                uuid: 2fb6e2af-125c-4dd4-8a86-3495a89ee87c
                topic: Reinforcement learning
                front: Co nezná pasivní učení?
                back: >
                        Agent nezná transition model [$]P(s'|s,a)[/$],
                        reward function [$]R(s)[/$] (postupně se učí z perceptů).
        -
                uuid: 105d7079-f317-4368-a9a3-f1541d832c30
                topic: Reinforcement learning
                front: Direct utility estimation - jak funguje? Proč je neefektivní?
                back: >
                        Postupně sampluj pro každý stav jaké discountované utility jsme viděli.
                        Stane se z toho supervised learning.<br>

                        Neefektivita: Nepoužíváme Bellmanovy rovnice -- prohledávaný prostor
                        obsahuje fůru funkcí co je nesplňují a pomalu konvergujeme.
        -
                uuid: 56c13553-e810-4ba1-9b36-d0e032c98581
                topic: Reinforcement learning
                front: Bellmanovy rovnice pro zafixovanou policy
                back: >
                        [$$]U^\\pi(s)=R(s)+\\gamma \\sum_{s'} P(s'|s,\\pi(s)) U^\\pi(s')[/$$]
        -
                uuid: 06a2032d-46dd-4da7-925c-711687a73d4e
                topic: Reinforcement learning
                front: Adaptive dynamic programming - co se učí? K čemu?
                back: >
                        Učí se transition model [$]P(s'|s,\\pi(s))[/$],
                        odměny [$]R(s)[/$].<br>
                        Pomocí Bellmanových rovnic (například pomocí modified
                        policy iteration) se učí utilitu stavů.
        -
                uuid: 1fdc283e-9b4e-4b5a-8ab2-a1ac6668df78
                topic: Reinforcement learning
                front: Pasivní ADP agent
                back: >
                        Když jsem ještě neviděl stav: řekni že initial utility je reward, [$]R[s]=r'[/$] reward signál
                        <br>
                        Jestli jsem přišel z jiného stavu, inkrementuj počet pozorovaných přechodů.
                        Updatuj tabulku viděných přechodů -- [$]P(t|s,a)\\leftarrow N_{s'|sa}[t,s,a]/N_{sa}[s,a][/$]
                        <br>
                        [$]U[/$] urči přes policy evaluation.
        -
                uuid: e42e5279-659a-48b2-9f03-831c0e7fc967
                topic: Reinforcement learning
                front: (Passive) temporal-difference learning -- update
                back: >
                        Používám viděné přechody na postupné updatování utilit.<br>

                        Update:
                        [$$]U^\\pi(s)\\leftarrow U^\\pi(s)+\\alpha\\cdot(R(s) + \\gamma U^\\pi(s') - U^\\pi(s))[/$$]
        -
                uuid: 98b6eeca-65b2-4390-b02d-79299e42547d
                topic: Reinforcement learning
                front: Porovnání ADP a TD
                back: >
                        Temporal difference learning nepotřebuje transition model.
                        Na jeden observed transition udělá jeden update.<br>
                        Adaptive dynamic programming udělá bulk update.
                        Po každé iteraci chce konzistanci, takže když narazí na
                        překvapení, udělá rychlou propagaci.
        -
                uuid: 99f3d30a-3855-41b1-9704-ed6765005e04
                topic: Reinforcement learning
                front: Active reinforcement learning - forma Bellmanových rovnic co by mělo splňovat ADP
                back: >
                        Vybírám optimální akci.
                        [$$]U^\\pi(s)=R(s)+\\gamma \\max_a \\sum_{s'} P(s'|s,a) U^\\pi(s')[/$$]
        -
                uuid: 625edded-3b66-4b4c-9b28-330306392933
                topic: Reinforcement learning
                front: Problémy s active reinforcement learningem přes maximalizaci Bellmanových rovnic
                back: >
                        Je to greedy agent. Nenaučil se totiž, co všechno prostředí umožňuje.<br>
                        Musím udělat exploration/exploitation trade-off.
        -
                uuid: f33a95a2-8be5-4095-a52f-07a3b55d601f
                topic: Reinforcement learning
                front: Jak integrovat exploraci?
                back: >
                        Občas udělat náhodnou akci: je extrémně pomalé.
                        <br>
                        Přidat exploraci do odhadu na utilitu:
                        [$$]
                        U^+(s)\\leftarrow R(s)+\\gamma\\max_a f(\\sum_{s'} P(s'|s,a) U^+(s'), N(s,a))
                        [/$$]
                        Kde [$]N(s,a)[/$] je kolikrát jsme to viděli,
                        [$]U^+[/$] je optimistický odhad utility,
                        [$]f(u,n)[/$] stoupá v [$]u[/$], klesá v [$]n[/$] (například [$]1[/$] pokud [$]n<100[/$], jinak [$]u[/$])
        -
                uuid: b7a2ae3f-3106-438d-8cc5-12b6b5879993
                topic: Reinforcement learning
                front: Q-learning -- Q-funkce
                back: >
                        [$]Q(s,a)[/$] je hodnota akce [$]a[/$] ve stavu [$]s[/$].
                        Je model-free.
        -
                uuid: 6363b605-6198-495b-ac6e-5f3f94607617
                topic: Reinforcement learning
                front: Vztah mezi Q funkcí a utilitou
                back: >
                        [$$]U(s)=\\max_a Q(s,a)[/$$]
        -
                uuid: 005c51b9-bad7-4633-b0e8-b09d403a7746
                topic: Reinforcement learning
                front: Q-learning -- rovnice která by měla platit postupně
                back: >
                        [$$]Q(s,a)=R(s)+\\gamma\\sum_{s'}P(s'|s,a)\\max_{a'}Q(s',a')[/$$]
                        Ale nebudu se na to učit explicitní model.
        -
                uuid: d4051f59-bde9-44be-b403-95cfd74d6b3e
                topic: Reinforcement learning
                front: Q-learning -- rovnice která by měla platit postupně
                back: >
                        [$$]Q(s,a)=R(s)+\\gamma\\sum_{s'}P(s'|s,a)\\max_{a'}Q(s',a')[/$$]
                        Ale nebudu se na to učit explicitní přechodový model.
        -
                uuid: 08559802-8f4c-4c41-ae11-6a2072109c0d
                topic: Reinforcement learning
                front: Q-learning -- update
                back: >
                        Update se provede kdykoliv udělám akci [$]a[/$] a skončím tím ve stavu [$]s'[/$].<br>
                        [$$]Q(s,a)\\leftarrow Q(s,a)+\\alpha(R(s)+\\gamma\\max_{a'}Q(s',a')-Q(s,a))[/$$]
                        <br>
                        Policy vyberu tak abych zase nějak podporoval exploraci.
        -
                uuid: 80a8a8f3-3537-4911-8e9d-8b5f38553cfe
                topic: Reinforcement learning
                front: SARSA -- zkratka
                back: State-Action-Reward-State-Action
        -
                uuid: 6ea21443-2301-44b6-ae1f-55cc2f09725f
                topic: Reinforcement learning
                front: SARSA -- update rule, změna z Q-learning
                back: >
                        SARSA:
                        [$$]
                        Q(s,a)\\leftarrow Q(s,a)+\\alpha(R(s)+\\gamma Q(s',a')-Q(s,a))
                        [/$$]
                        <br>
                        Provede se při každém [$]s,a,r,s',a'[/$] přechodu.
                        <br>
                        Q-learning:
                        [$$]
                        Q(s,a)\\leftarrow Q(s,a)+\\alpha(R(s)+\\gamma \\max_{a'} Q(s',a')-Q(s,a))
                        [/$$]
        -
                uuid: 15ee1ee2-e64d-41f8-98ae-0fbd136a0b53
                topic: Reinforcement learning
                front: SARSA vs. Q-learning
                back: >
                        Když agent je greedy, jsou identické.
                        <br>
                        Když exploruje, je tam drobný rozdíl. Q-learning
                        vůbec nezajímá, jaká policy se doopravdy následuje.
                        Dokáže se naučit i když má adversarial nebo náhodnou
                        exploration policy.
                        <br>
                        SARSA je realističtější. Funguje i když ostatní agenti
                        částečně ovládají policy.
        -
                uuid: 38101815-5bf6-4285-b98f-1001cf9f9e0b
                topic: Reinforcement learning
                front: Rozdíly mezi Q-learningem a SARSOU vs. ADP
                back: >
                        Q-learning, SARSA se učí action-utility funkci bez modelu.
                        Lokální updaty neenforcují konzistenci Q-hodnot.<br>
                        Intuice: čím složitější je prostředí, tím
                        užitečnější je dobrá reprezentace (ADP)
        # AI2 lecture06eng
        -
                uuid: 9dbae52a-38b4-4a95-bbf8-f66c42d75c1d
                front: Decision network
                back: >
                        Chance node (ovál): náhodné proměnné (jako v Bayesovských sítích)<br>
                        Decision node (obdélník): body kde decision maker dělá rozhodnutí<br>
                        Utility node (kosočtverec): utilita
        -
                uuid: 4217ab1f-1fc0-4820-a29f-8dcb1d89009b
                front: Sensitivity analysis
                back: >
                        Zjistit, co se stane, když trochu tweaknu hodnoty co jsou
                        v (Bayesovském) modelu. (Neměl bych mít příliš citlivý model.)
        -
                uuid: 6c711d32-c727-471f-b07f-66b11984776b
                front: Markovian state transition model
                back: >
                        Pevné pravděpodobnosti [$]P(s'|s,a)[/$].
        -
                uuid: 2369ac01-bbe0-4a4f-a410-1fa83ebb4a99
                front: Markov decision process
                back: >
                        Sequential decision problem for a fully observable,
                        stochastic environment with a Markovian transition
                        model and additive rewards.
        -
                uuid: 7471ca66-e741-414b-ae98-e5498bf8bf41
                front: What's the decision to a MDP?
                back: >
                        A policy ([$]\\pi(s)[/$]).
                        Optimal policy: highest expected utility.
        -
                uuid: dcda144b-a485-4371-879d-a01924638ea8
                front: How to deal with utilities over time?
                back: >
                        A. Finite horizon; after some time, nothing matters.
                        B. Infinite horizon: optimal policy is stationary.
                        <br>
                        Rewards: additive or discounted. Discounting: exponential.
        -
                uuid: 6e18efe6-ac68-41ad-89a1-026ad9d92e42
                front: Expected utility from policy and reward function
                back: >
                        [$$]U^\\pi(s)=E[\\sum_{i=0\\ldots\\infty} \\gamma^i R(S_i)][/$$]
        -
                uuid: a24296e7-25ea-45a3-bd3c-f6366122bf8d
                front: Definition - true utility of state; how to go from that to best policy
                back: >
                        [$$]U(s)=U^{\\pi^{ * }}(s)[/$$]

                        Optimal policy:
                        [$$]\\pi^{ * }(s)=\\arg\\max_a \\sum_{s'}P(s'|s,a)U(s')[/$$]
        -
                uuid: 82c49ae3-c696-46a2-aa58-c71e0458d26c
                front: Bellman equation for true utilities
                back: >
                        [$$]U(s)=R(s)+\\gamma\\max_{a}\\sum_{s'}P(s'|s,a)U(s')[/$$]
        -
                uuid: 319b02b0-a895-4c26-a5b9-3cefc387fcd1
                front: Value iteration algorithm
                back: >
                        Začnu s náhodnými počátečními hodnotami.
                        Pak postupně dělám Bellmanovský update:
                        [$$]
                        U_{i+1}(s)\\leftarrow R(s)+\\gamma\\max_a \\sum_{s'}P(s'|s,a)U(s')
                        [/$$]
                        <br>
                        Potřebuju mít přechodový model.

                        Jakmile se utilita už mění jenom málo ([$]\\delta < \\varepsilon (1-\\gamma)/\\gamma[/$]), skonči.

                        Kde [$]\\varepsilon[/$] je limit, jak daleko si dovolím být od skutečných utilit.
        # TODO: konvergence value iteration
        -
                uuid: 6d4c7aeb-065e-41da-beec-10d8ff00d117
                topic: Predikátová logika
                front: Značení - hodnota formule v ohodnocení a struktuře
                back: >
                        [$$]H^A(\\varphi)[e][/$$]
        # AI2 lecture01eng
        -
                uuid: 8c7866c5-262c-4b97-9ad5-3e5619aed06b
                front: Nejistota v logických agentech a problémy
                back: >
                        Musí počítat se všemi, i nepravděpodobnými možnostmi,
                        které jsou logicky konzistentní, a to i v plánech,
                        které jsou pak ohromné. Občas musíme jednat
                        i když není žádná akce co nutně logicky vede
                        k úspěchu.
        -
                uuid: 13e89e28-588c-4a78-8307-2ad1c00ad69d
                topic: Nejistota
                front: Definice podmíněné pravděpodobnosti
                back: >
                        [$$]P(A|B)=P(A&B) / P(B)[/$$]
                        <br>
                        (povinně [$]P(B)>0[/$])
        -
                uuid: 7b3a872d-2057-4b5e-9581-6de29cafc492
                topic: Nejistota
                front: Axiomy pravděpodobnosti
                back: >
                        [$$]P(\\neg A)=1-P(A)[/$$]
                        [$$]P(A\\vee B)=P(A)+P(B)-P(A\\wedge B)[/$$]
                        [$$]\\mathbf{P}(A,B,C,D)=\\mathbf{P}(A|B,C,D)\\mathbf{P}(B,C,D)=\\ldots[/$$]
        -
                uuid: e686aa77-2800-490f-a64d-18268bc9b0e1
                topic: Nejistota
                front: Jak získat posteriory z KB, co je full joint distribution?
                back: >
                        Marginalizace:<br>
                        [$$]P(\\Phi)=\\sum_{\\omega: \\omega\\vDash\\phi} P(\\omega)[/$$]
                        [$$]\\mathbf{P}(\\mathbf{Y})=\\sum_{z\\in\\mathbf{Z}}\\mathbf{P}(\\mathbf{Y},z)[/$$]
        -
                uuid: 09c54a08-9e8c-4ef6-b70a-f9bcc58ff9cf
                topic: Nejistota
                front: K čemu je normalizace?
                back: >
                        [$$]P(\\neg a|b) = P(\\neg a \\wedge b) / P(b)[/$$]
                        [$$]P(a|b)=P(a\\wedge b)/P(b)[/$$]

                        Když nás zajímá [$]\\mathbf{P}(A|b)[/$],
                        stačí: [$]\\mathbf{P}(A|b)=\\alpha \\mathbf{P}(A,b)[/$]
                        -- dělitelé jsou stejní, víme že se to má posčítat na 1.
        -
                uuid: 5743e1a2-606e-4383-bc3b-f53fb76ad491
                topic: Nejistota
                front: Problémy s inferencí pomocí enumerace (skrz skryté proměnné)
                back: >
                        Časová složitost [$]\\O(d^n)[/$] ([$]d[/$] je velikost domény).
                        Prostor [$]\\O(d^n)[/$]. Není feasible zjistit všechny
                        pravděpodobnosti všech možných světů.
        -
                uuid: 258e0929-9895-47a2-9968-16d21be4be9c
                topic: Nejistota
                front: Definice - Nezávislost proměnných
                back: >
                        [$]\\mathbf{P}(X|Y)=\\mathbf{P}(X)[/$],
                        nebo [$]\\mathbf{P}(Y|X)=\\mathbf{P}(Y)[/$],
                        nebo [$]\\mathbf{P}(X,Y)=\\mathbf{P}(X)\\cdot \\mathbf{P}(Y)[/$].
        -
                uuid: eab2cd2a-b534-4b5d-8f1d-75e81aecf0d2
                topic: Nejistota
                front: Definice - Podmíněná nezávislost
                back: >
                        Catch, Toothache jsou nezávislé, pokud známe hodnotu Cavity.
                        <br>
                        [$]\\mathbf{P}(X|Y,Z)=\\mathbf{P}(X|Y)[/$], nebo
                        [$]\\mathbf{P}(Z|X,Y)=\\mathbf{P}(Z|Y)[/$], nebo
                        [$]\\mathbf{P}(Z,X|Y)=\\mathbf{P}(Z|Y)\\cdot\\mathbf{P}(X|Y)[/$]
        -
                uuid: 795b5ac9-50f2-4770-8fa5-b414609466ee
                topic: Nejistota
                front: Bayesovo pravidlo, pro jevy
                back: >
                        [$$]P(a|b)=P(b|a)\\cdot P(a)/P(b)[/$$]
        -
                uuid: 0fefc9eb-5229-4955-ace8-1185d87e36e0
                topic: Nejistota
                front: Bayesovo pravidlo, pro proměnné
                back: >
                        [$$]\\mathbf{P}(Y|X)=\\mathbf{P}(X|Y)\\mathbf{P}(Y)/\\mathbf{P}(X)=\\alpha \\mathbf{P}(X|Y)\\mathbf{P}(Y)[/$$]
        -
                uuid: e0b75cca-9f94-447e-a4c9-c068029e0a4b
                topic: Nejistota
                front: Kauzální vs. diagnostický směr
                back: >
                        Kauzální: [$]P(effect|cause)[/$], diagnostický: [$]P(cause|effect)[/$]
        -
                uuid: 6ee8d234-650e-4232-9f72-c12f0ccfd311
                front: Naivní Bayesovský klasifikátor
                back: >
                        Když jsou všechny efekty nezávislé při pevné příčině,
                        dostaneme:
                        [$$]\\mathbf{P}(Cause, E_1,\\ldots E_n)=\\mathbf{P}(Cause)\\product_i \\mathbf{P}(Eff_i|Cause)[/$$]
                        <br>
                        Často se používá i když efekty ve skutečnosti nezávislé nejsou.
        # ai1 lecture02eng
        -
                uuid: 458503cb-d268-44b8-99ce-1b26c29b5bb5
                front: Struktura Bayesovské sítě
                back: >
                        Acyklický graf, hrana když existuje závislost, ve vrcholech
                        jsou podmíněné pravděpodobnostní distribuce.
        -
                uuid: 8a052ca5-55e4-40f6-b727-ccff6d31d155
                front: Vzorec pro jak z podmíněných distribucí v Bayesovské síti dostat pravděpodobnost jednoho světa
                back: >
                        [$$]P(x_1,\\ldots x_n) = \\product_i P(x_i | \\text{parents}(X_i))[/$$]
        -
                uuid: e3f59843-753e-4dbd-bb66-8d1e4da31d8a
                front: Podmíněné nezávislosti proměnných v Bayesovské síti?
                back: >
                        Proměnná je podmíněně nezávislá na proměnných, které
                        nejsou její potomci, pokud známe její rodiče.
                        <br>
                        Proměnná je podmíněně nezávislá na všech ostatních
                        proměnných, pokud známe rodiče, potomky a rodiče potomků
                        (*Markov blanket*).
        -
                uuid: 6a0c788e-a08d-4c05-b66f-c458a4a4ef27
                front: Základní algoritmus pro výpočet v Bayesovské síti
                back: >
                        Enumeration-Ask: dostane proměnnou a zafixovaná pozorování,
                        vrátí její distribuci.
                        Postupně vyzkouší všechny hodnoty a zavolá na nich Enumerate-All,
                        pak výsledky znormalizuje a vrátí distribuci.<br>
                        <br>
                        Enumerate-All: dostane proměnné (iniciálně všechny
                        v Bayesovské síti) a zafixovaná pozorování.
                        <br>
                        Když proměnné jsou prázdné, vrať 1.
                        <br>
                        Když první proměnná má dosazenou hodnotu,
                        vrať [$]P(Y=y|Pa(Y)) \\times EnumAll(Rest(vars),e)[/$].
                        <br>
                        Jinak vrať [$]\\sum_y P(Y=y|Pa(Y)) \\times EnumAll(Rest(vars),e)[/$].
        -
                uuid: a893942d-0f71-4e5f-b89a-1d569dd69cfd
                topic: Bayesovské sítě
                front: Faktor, operace na faktorech
                back: >
                        Faktor: tabulka s proměnnými, hodnotami a pravděpodobnostmi.
                        Taky se jim říká "potenciály".
                        <br>
                        Násobení faktorů: spojím, pointwise.
                        <br>
                        Sum out (marginalizace): [$]\\sum_a f(A,B,C)=f(B,C)[/$]
        -
                uuid: d216a6ba-dff4-4174-88e6-72c1bd245542
                topic: Bayesovské sítě
                front: Inferenční algoritmus Eliminace proměnných, jeho složitost. Jak vypadá sum-out?
                back: >
                        Vstup: query proměnná, evidence, belief net.<br>

                        Faktory: [], proměnné: síť topologicky od příčin k důsledkům<br>

                        Pro každou proměnnou:
                        přidej na začátek faktorů [$]Make-Factor(var,e)[/$].
                        <br>
                        Jestli je proměnná skrytá, tak ji z faktorů vysčítej (vymarginalizuj).
                        <br>
                        Vrať: normalizovaný pointwise produkt všech faktorů.
                        <br>
                        Složitost: velikost největšího faktoru
                        <br><br>
                        Sum-out:
                        Sesumíruje dohromady všechny faktory, které obsahují
                        skrytou proměnnou -- do jednoho velkého faktoru.
        -
                uuid: 1126f580-6ff1-4743-8e1d-c15d2c28d02f
                front: Variable Elimination -- čím se ovlivní složitost?
                back: >
                        Tím, v jakém pořadí eliminuju proměnné. (Resp., procházím je.)
                        Musí jít topologicky, ale kromě toho mám svobodu.
        -
                uuid: 7684e87e-ad83-4e87-89ea-13b39a8d8bd0
                front: Variable Elimination -- jak je těžké najít optimální pořadí eliminace?
                back: >
                        NP-těžké
        -
                uuid: d06b451e-76f2-4173-93c6-f3d06eda8631
                front: Variable Elimination -- podle jaké heuristiky můžu vybrat další proměnnou k eliminaci?
                back: >
                        Tu, která povede na vyrobení nejmenšího faktoru.
        -
                uuid: 8a4e1e23-0a38-4bf8-8112-edabc065adcd
                front: Jak složitá je inference v Bayesovské síti co je les?
                back: >
                        [$]\\O(n\\cdot d^k)[/$] čas i prostor (tj. stejně jako součet velikosti všech tabulek)
        -
                uuid: 587e5c4f-9b08-4071-b4e0-d4f5d0d90f4c
                front: Jak složitá je inference v Bayesovské síti?
                back: >
                        Obecně NP-těžká, resp. Sharp-P těžká (převodem z 3-SATu)
        -
                uuid: 18d150c2-553e-4350-b57e-a81b9fcda507
                front: >
                        Algoritmy přibližné inference pro Bayesovské sítě
                back: >
                        Přímé vzorkování, Markov chain sampling
        -
                uuid: c4d80bf8-75ec-4751-84fc-1248445f9384
                front: >
                        Přímé vzorkování v Bayesovských sítích, rejection sampling
                back: >
                        Vezmu proměnné v topologickém pořadí, postupně
                        si házím korunami podle pravděpodobností daných rodiči.
                        <br>
                        Rejection sampling: vygeneruju vzorek, mrknu jestli sedí
                        na pozorování, jinak ho zahodím. Když sedí, tak
                        s jeho pomocí stavím [$]\\mathbf{P}(X|e)\\simeq \\mathbf{N}(X,e)/N(e)[/$].
        -
                uuid: 080a09bb-4d88-4031-b6db-cfc663d1f4fc
                front: Likelihood weighting
                back: >
                        Nechci zahazovat vzorky jako v rejetction samplingu.
                        <br>
                        Zafixuju evidence variables, sampluju jenom non-evidence
                        variables.
                        <br>
                        [$$]\\mathbf{P}(X|e)=\\alpha \\mathbf{N}(X,e) w(X,e)[/$$]
                        <br>
                        Kde: [$]w(X,e)=\\product_j P(e_j|parents(e_j))[/$]
                        <br>
                        (Bayesovo pravidlo. [$]P(z,e)=\\product_i P(z_i|parents(z_i))[/$])
                        <br>
                        Elegantně: když proměnná má přiřazenou viděnou hodnotu,
                        vynásob hmotnost vzorku pravděpodobností, že tuhle
                        hodnotu dostane. Když ji nemá, hoď ji náhodně podle
                        distribuce z jejich rodičů.
        -
                uuid: eddcc300-85af-4c39-a7f8-3bf8419eced6
                front: >
                        MCMC: co to je za zkratku?
                back: Monte Carlo Markov chain
        -
                uuid: 06ab77e1-96f2-462e-aa74-974836db5668
                front: Jak funguje MCMC?
                back: >
                        Další vzorek dostanu tak, že vezmu nějakou proměnnou
                        co není v evidence a znova ji nasampluju podle její
                        Markovské obálky.
        -
                uuid: 330e605f-c69b-4a48-828f-5bc95fdc83a8
                front: Proč funguje MCMC?
                back: >
                        Samplovací proces bude dlouhodobě trávit ve stavu
                        poměr odpovídající jeho pravděpodobnosti.
                        <br>
                        Označ: [$]q(x\\rightarrow x')[/$] přechod ve stavu,
                        [$]\\pi_t(x)[/$] pravděpodobnost že jsem ve stavu v čase.
                        <br>
                        Vždy platí: [$]\\pi_{t+1}(x')=\\sum_x \\pi_t(x)q(x\\rightarrow x')[/$].
                        <br>
                        Pro stacionární distribuci musí platit:
                        [$]\\pi(x')=\\sum_x \\pi(x) q(x\\rightarrow x')[/$].
                        <br>
                        Tohle platí například když [$]\\pi(x)q(x\\rightarrow x')=\\pi(x')q(x'\\rightarrow x)[/$].
                        <br>
                        Ať jsme změnili proměnnou [$]X_i[/$] z [$]x_i[/$] na [$]x_i'[/$]
                        a ostatní ([$]Y_i[/$] s hodnotami [$]y_i[/$]) nechali.<br>
                        [$$]q(x\\rightarrow x')=P(x_i'|y_i, e)=P(x_i'|mb(X_i))[/$$]
                        (Říká se tomu Gibbs sampling.)
                        <br>
                        [$$]\\pi(\\mathbf{x}) q(\\mathbf{x}\\rightarrow \\mathbf{x}')=
                        P(\\mathbf{x}|\\mathbf{e}) P(x_i'|\\mathbf{y}_i,e) =
                        P(x_i,\\mathbf{y}_i|\\mathbf{e})P(x_i'|y_i,e)=[/$$]
                        [$$]=P(x_i|y_i,e) P(y_i|e) P(x_i'|y_i,e) =[/$$]
                        [$$]=P(x_i|y_i,e) P(x_i',y_i|e) = q(x'\\rightarrow x)\\pi(x')[/$$]
