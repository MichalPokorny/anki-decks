deck: Magisterské státnice::Datové struktury
notes:
        -
                uuid: ae5a81b0-dec8-4bd1-bd6b-5f1c8f7fb3eb
                front: Základní vlasnost binárních vyhledávacích stromů
                back: V pořadí zleva doprava v DFS jsou klíče uspořádané od nejmenšího po největší.
        -
                uuid: caf785f4-dcf0-400e-9c72-dd0f8b5b5ba5
                front: Na jaké vlastnosti záleží doba vyhledávání ve vyhl. stromu? Jak se to optimalizuje?
                back: >
                        Na hloubce vrcholů. Systematické vyvažování: AVL/red-black/...; (a,b)-stromy; "dynamicky": splay stromy
        -
                uuid: 017590ba-1c6b-43b3-9454-5641a154476d
                front: >
                        [$] (a,b)[/$]-stromy: význam [$]a[/$], [$]b[/$], invariant

                        Kde jsou hodnoty? Co je ve vnitřních uzlech?
                back: >
                        [$]a\\geq 2[/$], [$]b\\geq 2a-1[/$]

                        Každý vrchol má aspoň [$]a[/$] a nejvýš [$]b[/$] synů ([$]\\in[a;b][/$])

                        Hodnoty jsou v listech. Vnitřní uzly obsahují maxima svých podstromů.
        -
                uuid: eebfb938-29c8-4db5-aedb-9b62c93a96b5
                front: Kolik listů má [$] (a,b) [/$]-strom dané hloubky? Jakou má hloubku, podle množství listů?
                back: >
                        Mezi [$]a^{d-1}[/$] a [$]b^d[/$]. Hloubka: [$]\\log_b n \\leq d \\leq 1 + \\log_a n[/$].
        -
                uuid: abb7a7f3-7173-492b-b118-3e7b6f7ea15b
                front: >
                        [$] (a,b)[/$]-strom -- Insert
                back: >
                        1. Najdi vrchol *v*, pod který patří nový list.<br>

                        2. Pokud má *v* míň než [$]b[/$] synů, přidej pod něj *v* <br>

                        3. Pokud má *v* [$]b[/$] synů, rozštěp ho na dva, co má každý [$] (b+1)/2 [/$] synů. Rekurzivně vlož do otce.
        -
                uuid: 163b97da-16f0-493e-a772-66e7b80956b9
                front: >
                        [$] (a,b)[/$]-strom -- Delete
                back: >
                        1. Pokud otec mazaného listu obsahuje [$]>a[/$] synů, odmaž list a je to.<br>

                        2. Pokud otec spolu s levým nebo pravým sourozencem obsahuje [$]>2a[/$] synů, jednoho přesuň a smaž [$]v[/$]. Zaktualizuj informace o maximech.<br>

                        3. Jinak otce a strýce sluč a rekurzivně pokračuj nahoru.
        -
                uuid: e6660a05-296f-4e06-84bc-2f8c520aff01
                front: >
                        [$] (a,b)[/$]-strom -- Join
                back: >
                        Spojí ztromy [$]T_1[/$], [$]T_2[/$], pokud [$]\\max T_1 < \\min T_2[/$].<br>

                        Ať je [$]T_1[/$] ten vyšší. [$]r=d(T_1) - d(T_2)[/$]<br>

                        Syny kořene [$]T_2[/$] přidej najednou k synům posledního vrcholu na hladině [$]r[/$] ve stromě [$]T_1[/$].<br>
                        Pokud bude mít moc synů, rozštěp ho jako při Insertu. Složitost: [$]\\O(d(T_1) - d(T_2))[/$]
        -
                uuid: 97fefc3c-d1b3-4bc2-a7ab-5acb6e67718f
                front: >
                        [$] (a,b)[/$]-strom -- Split
                back: >
                        Rozdělí strom na dva, jeden s klíči [$]<k[/$], druhý [$]\\geq k[/$].<br>

                        Máme dva zásobníky: jeden pro levé stromy, druhý pro pravé.<br>
                        Postupuj jako při Find, rozděluj přitom na [$]T_L[/$], [$]T_k[/$], [$]T_P[/$].<br>
                        Postupně plň zásobníky. Pak postupně pojoinuj stromy v zásobnících,
                        takže Split bude trvat [$]\\O(\\log n)[/$].
        -
                uuid: b56212a0-6576-40e6-b4ea-850ff2d6561e
                front: >
                        [$] (a,b)[/$]-strom -- amortizovaný počet štěpení a splučování v sekvenci Insertů a Deletů
                back: >
                        [$]\\O(m+\\ell+\\log n)[/$] splitů na [$]m[/$] Insertů,
                        [$]\\ell[/$] Deletů, takže [$]\\O(1)[/$] amortizovaně
                        splitů/insertů za operaci<br>

                        Předpoklad: [$]b\\geq 2a[/$]
        -
                uuid: 34d286ac-489f-42df-89f4-be0f7ec168ab
                front: A-sort a jeho složitost
                back: >
                        Postupně vkládej do [$] (a,b)[/$]-stromu, pak je vypiš během DFS.<br>

                        Drž si prst na poslední vložený prvek, od něj dělej hledání při vkládání dalšího.<br>

                        Celkový čas: [$]\\leq 2 \\sum_{i=1}^n \\log_a |{j\\leq i, x_i < x_j}| + \\O(n)[/$]<br>

                        ([$]\\log[/$] je konkávní)<br>

                        [$$]\\leq 2n \\log_a \\frac{\\sum_i |{j\\leq i, x_i < x_j}|}{n} = \\O(n\\log(F/n))[/$$]

                        [$]F[/$]: počet "inverzí"<br>

                        Alternativně: hledání od nejpravějšího listu [$]\\rightarrow \\leq 1 + \\log_a |\\{j < i+1, x_j > x_i\\}|[/$]
        -
                uuid: cede43cf-fed3-463f-abe4-646bd6fc51aa
                front: Red-black trees -- axiomy
                back: >
                        Každý uzel je červený nebo černý.<br>
                        Červené uzly mohou být syny pouze černých uzlů (nemůže být červený uzel pod červeným).<br>
                        Na každé cestě do listu je stejný počet černých vrcholů.<br>
                        Hodnoty jsou ve vnitřních vrcholech.
        -
                uuid: 121e2648-cfe6-4f4a-8ad3-642a376baae5
                front: Red-black trees -- ekvivalence s [$] (a,b) [/$]
                back: >
                        Ekvivalentní [$] (2,3) [/$]-stromům. Jsou tři možnosti: vrchol je červený a má dva černé syny; je černý a má dva červené syny; je černý a má jednoho červeného syna. To jsou gadgety na 4, 2, 3 syny.
        -
                uuid: b2e3d4a9-a888-45cc-b1ab-182fc1390bc1
                front: Preventativní půjčování a štěpení
                back: >
                        Při insertu preventativně štěp všechno co má [$]b[/$] synů.
                        Při deletu při hledání od kořene uprav každý vrchol s [$]a[/$]
                        syny buď přidáním syna ze sourozence nebo slitím se sourozencem.
        -
                uuid: 781d7242-25bd-4b2a-8862-f80a6ebc397e
                front: Vlastnosti splay stromu - maximální, amortizovaná cena vkládání
                back: >
                        Na operaci: až [$]\\O(n)[/$]

                        Cena za [$]m[/$] operací, [$]n[/$] vložených prvků: [$]\\O(m\\log n+n\\log n)[/$]
        -
                uuid: f0795afe-ab1d-4293-a1ad-e6f88a9c80f5
                front: Operace Splay
                back: >
                        [$]Splay(x)[/$]

                        Případy:

                        A:
                        <pre>
                               z              x
                              / \            / \
                             y   .          .   y
                            / \        ==>     / \
                           x   .              .   z
                          / \                    / \
                         .   .                  .   .
                        </pre>

                        B:
                        <pre>
                               z                   x
                              / \                /  \
                             y   .              y    z
                            / \        ==>     / \  / \
                           .   x              .   ..   .
                              / \
                             .   .
                        </pre>

                        C: (u kořene)
                        <pre>
                             y                     x
                            / \                   / \
                           x   .     ==>         .   y
                          / \                       / \
                         .   .                     .   .
                        </pre>
        -
                uuid: 5071f3a5-9735-46ce-90d8-e13d3e9d9eea
                front: Amortizovaný čas na Splay -- jak vyjde, další kroky v důkazu
                back: >
                        [$]t = a + \\Phi(T') - \\Phi(T)[/$], kde [$]a[/$] je skutečný čas, [$]\\Phi[/$] je potenciál, [$]t[/$] je amortizovaný čas

                        [$]\\Phi(t) := \\sum_{x\\in T}r(x); r(x) := \\log_2([/$]počet vrcholů pod [$]x)[/$]

                        Čas na [$]m[/$] operací: [$]\\sum^m t_i = \\sum^m [a_i + \\Phi(T_i) - \\Phi(T_{i-1})] = (\\sum^m a_i) + \\Phi(T_m) - \\Phi(T_0) \\Rightarrow \\sum^m a_i = \\sum^m t_i + \\Phi(T_0) - \\Phi(T_m)[/$],
                        tedy čas na [$]m[/$] operací je [$]m \\O(\\log n) + \\O(n \\log n)[/$]

                        Budeme chtít dokázat, že jednotlivé cases ve Splay nemění moc potenciál.
        -
                uuid: 263424b5-62f8-4d35-a8ae-c17bece6d6fb
                front: Amortizovaný čas na Splay -- obecný postup
                back: >
                        Rozeberu po případech, že počet amortizovaných rotací je
                        [$$]t\\leq 1+3(r(v)-r(x))[/$$]
                        Kde [$]v[/$] je původní kořen.

                        Amortizovaný čas na Splay je [$]\\leq 1 + 3\\log_2 n[/$].
        -
                uuid: 041041da-2e5b-4696-95c9-94c1e7f4855b
                front: Amortizovaný čas na Splay -- na případ [$]z\\rightarrow y\\rightarrow x \\Rightarrow z\\leftarrow x\\leftarrow x[/$]
                back: >
                        [$$]t \\leq 2 + r'(x) - r(x) + r'(y) - r(y) + r'(z) - r(z)[/$$]

                        [$]r(z) = r'(x)[/$], tedy [$]= 2 - r(x) + r'(y) - r(y) + r'(z)...[/$]

                        Protože [$]r'(y) \\leq r'(x)[/$] (protože potom je [$]y[/$] pod [$]x[/$]) a [$]r(y) \\geq r(x)[/$]:
                        [$$]t \\leq 2 - r(x) + r'(x) - r(x) + r'(z) = 2 + r'(x) - 2r(x) + r'(z)[/$$]

                        Pozorování: [$]2 \\leq 2r'(x) - r(x) - r'(z)[/$]

                        Totiž:
                        [$$]r'(x) = \\log_2[|A| + |B| + |C| + |D| + 3][/$$]
                        [$$]r'(y) = \\log_2[|A| + |B| + 1][/$$]
                        [$$]r'(z) = \\log_2[|C| + |D| + 1][/$$]

                        Povšimni si:
                        [$$]\\log_2 a + \\log_2 b \\leq 2\\log \\frac{a+b}{2}[/$$]

                        [$$]r'(x) = \\log(a+b+1)\\geq (\\log \\frac{a+b}{2})+1[/$$]

                        [$$]2r'(x)-r(x)-r'(z)\\geq 2[/$$]

                        Tedy: [$$]t\\leq 2+r'(x)-2r(x)+r'(z) \\leq 3r'(x)-3r(x)[/$$]
        -
                uuid: 065f235b-8a51-475a-a1b1-2a56296b940e
                front: Amortizovaný čas na Splay -- na případ [$]x \\rightarrow y \\leftarrow z[/$]
                back: >
                        [$$]t \\leq 2+r'(x)-r(x)+r'(y)-r(y)+r'(z)-r(z)[/$$]
                        [$$]= 2-r(x)+r'(y)-r(y)+r'(z)[/$$]
                        [$$]\\leq 2-2r(x)+r'(y)+r'(z)[/$$]

                        Pozorování: [$]2\\leq 2r'(x)-r'(y)-r'(z)[/$]

                        Tedy: [$$]\\leq 2r'(x)-2r(x)=2(r'(x)-r(x))[/$$]
        -
                uuid: cd420f77-33c2-4660-8c81-eefc5cc04e1b
                front: Amortizovaný čas na Splay -- na případ [$]x\\rightarrow y[/$] v kořeni
                back: >
                        [$$]t\\leq 1+r'(x)-r(x)+r'(y)-r(y)[/$$]

                        Poz.: [$]r'(y)<r(y)[/$], [$]r'(x)-r(x)>0[/$]

                        [$$]\\leq 1+r'(x)-r(x) \\leq 1+3(r'(x)-r(x))[/$$]
        -
                uuid: dc66b323-9313-4e90-9de3-e00034c2cf8e
                front: Splay strom -- Insert
                back: >
                        Vysplayuj nahoru poslední vrchol na cestě k chybějícímu [$]x[/$].

                        Podrozděl levou nebo pravou hranu z vysplayovaného kořene novým vrcholem [$]x[/$].
        -
                uuid: a95b34fc-04cd-4672-aaa9-ed11305aea42
                front: Splay strom -- Delete
                back: >
                        Vysplayuj nahoru vrchol co chci odebrat.
                        Odeber ho, nahraď ho nejmenším/největším z pravého/levého podstromu.
        -
                uuid: 7738e830-27af-432c-9f98-4266eae390e8
                front: Haldy -- obecný interface
                back: >
                        Insert, Min, DeleteMin
        -
                uuid: 98f1108a-eb48-4c63-ba19-aef0d126a539
                front: Regulární halda -- invariant, uložení do pole
                back: >
                        Invariant: Prvek je menší než všechny pod ním.
                        Pod [$]i[/$] jsou prvky [$]2i[/$], [$]2i+1[/$].
        -
                uuid: d77b8f43-105e-4074-8728-893e94fc4584
                front: Regulární halda -- Insert
                back: >
                        Přidej prvek na konec pole. Bublej ho směrem ke kořeni,
                        dokud je porušena podmínka, že otec je menší než syn.
        -
                uuid: 8a30657b-6486-43b4-b69c-4acb6d6c7777
                front: Regulární halda -- Delete
                back: >
                        Poslední prvek přesuň do prvního, bublej s menším ze synů směrem dolů dokud je otec větší než syn.
        -
                uuid: 53dbd39b-fe32-406d-9da8-b7d3f206bd0b
                front: Regulární halda -- časy
                back: >
                        Insert, DeleteMin: [$]\\O(\\log n)[/$], Min: [$]\\O(1)[/$]
        -
                uuid: a117f9b8-e1b0-4e51-8ed8-e67f2c8572d0
                front: Binomiální halda -- struktura
                back: >
                        Soubor haldově uspořádaných stromů velikostí [$]2^k[/$].
                        Pamatujeme si, který obsahuje minimální prvek.

                        Zbrklá varianta: nejvýše jeden strom dané varianty.

                        Líná varianta: bez omezení na počet stromů stejné velikosti.

                        Jeden binomiální strom obsahuje kořen a hned pod ním menší binomiální stromy všech menších velikostí.
        -
                uuid: f4b71aef-78b4-46b1-a788-42d1dc6620fc
                front: Eager binomiální halda -- Insert
                back: >
                        Přidej nový haldový strom velikosti 1,
                        postupně slívej dokud existují dva stromy stejné velikosti.
                        Aktualizuj ukazatel na strom s minimálním prvkem.
        -
                uuid: f90fa989-ff96-41b1-8a27-0eeaaa17cc8d
                front: Eager binomiální halda -- DeleteMin
                back: >
                        Odřízneme kořen stromu s minimálním prvkem. Rozpadne se na [$]i[/$] stromů velikosti [$]2^0, 2^1, \\ldots 2^{i-1}[/$].
                        Postupně slívej jako při Insertu.
        -
                uuid: f60d57a1-990f-4c50-8992-f9a82e172a74
                front: Eager binomiální halda -- složitosti
                back: >
                        Insert [$]\\O(\\log n)[/$], Min [$]\\O(1)[/$], DeleteMin [$]\\O(\\log n)[/$].

                        Stejně jako regulární halda, ale [$]n[/$] insertů trvá jenom [$]\\O(n)[/$] (amortizací přes inkrement).
                        (Takže amortizovaně [$]\\O(1)[/$] na Insert dokud se neprovede DeleteMin.)
        -
                uuid: 3badd3b1-40d5-4e0c-925a-3126f13208cf
                front: Líná binomiální halda -- Insert
                back: Vytvoř nový strom velikosti 1 a aktualizuj odkaz na minimum.
        -
                uuid: baad0a81-0faa-4a86-8dd4-552e0aa815d6
                front: Líná binomiální halda -- DeleteMin
                back: >
                        Odřízni kořen stromu s minimálním prvkem. Slévej stromy stejné velikosti dokud to jde.
        -
                uuid: 00bd62d4-b7b8-461d-a215-3ac8f38335b2
                front: Líná binomiální halda -- složitosti, důkazy
                back: >
                        Insert [$]\\O(1)[/$], Min [$]\\O(1)[/$], DeleteMin [$]\\O(n)[/$], ale amortizovaně [$]\\O(\\log n)[/$]

                        Potenciál: [$]\\Phi(T) = C \\cdot [/$] počet stromů v haldě

                        Insert: [$]\\leq C + \\Phi(T')-\\Phi(T) = C[/$]

                        DeleteMin: [$]\\leq C \\cdot [/$] počet stromů [$]+\\Phi(T')-\\Phi(T)\\leq C\\cdot\\log n = \\O(\\log n)[/$]
        -
                uuid: aa2bd2dc-0887-4116-b0fd-7920f52db5b5
                front: Model externí paměti -- notace
                back: >
                        [$]M[/$]: velikost paměti

                        [$]B[/$]: velikost přenášených bloků

                        [$]M/B[/$]: počet bloků v paměti
        -
                uuid: fc258cff-8cef-495b-a6ca-69afbc5252f9
                front: Model externí paměti -- složitost sekvenčního čtení
                back: >
                        [$]\\lceil N/B \\rceil + 1[/$]
        -
                uuid: c9501f8e-cfb7-4cda-b76c-997165ec1cdb
                front: Model externí paměti -- složitost binárního vyhledávání
                back: >
                        [$]\\log N - \\log B[/$]
        -
                uuid: 421b4c33-4f9e-4ceb-8ae5-55590e3be666
                front: Model externí paměti -- transpozice matice
                back: >
                        [$]N^2[/$] přenosů když [$]M/B < N[/$]

                        Když [$]M>B^2[/$], jde udělat algoritmus s [$]N^2/B[/$] přenosy (optimální).
                        Transponuj po podmaticích velikosti [$]B\\times B[/$].
        -
                uuid: b0008716-72b5-43cb-a275-0cc8975b732e
                front: Cache-oblivious algoritmy
                back: >
                        Algoritmus je navržený bez známého [$]M[/$], [$]B[/$].
                        Analyzujeme s tím, že to jsou neznámé.
        -
                uuid: 02c3fb00-23d9-4011-869f-9287b94fb132
                front: Transpozice matice cache-obliviously. Jaký má předpoklad?
                back: >
                        Rekurzivně po čtvrtinách. Předpoklad: [$]M\\geq B^2[/$] (tall cache assumption)

                        Jakmile se dostanu na velikost [$]B\\times B[/$], tak jedna transpozice trvá [$]B[/$] přenosů. Takových matic je [$]N^2/B^2[/$]. [$]\\O(N^2/B^2 \\cdot B)=\\O(N^2/B)[/$] I/O operací.
        -
                uuid: f7be2627-47a5-4c5e-bf80-bceaf95803dc
                front: van Emde-Boasovo uspořádání
                back: >
                        Useknu strom v půlce výšky. Nahoře je [$]\\sqrt{N}[/$] prvků, dole je [$]\\sqrt{N}[/$] stromů, každý velký [$]\\sqrt{N}[/$]. Uložím je za sebe.
                        Počet I/O operací: [$]\\frac{\\log n}{\\log \\sqrt{B}}=2\\log_B N[/$]

                        To je zlepšení proti binárnímu vyhledávání ([$]\\log N - \\log B[/$]).
        -
                uuid: f71b5948-d157-4aec-b0b5-4aa6544b839f
                front: Třídení -- optimální cache-oblivious složitosti
                back: >
                        Za předpokladu [$]M\\geq B^2[/$] jde [$]\\O(n\\log n)[/$] operací, [$]\\O(N/B \\log_{M/B}[N/B])[/$] I/O
        -
                uuid: cae253c8-de58-49f7-b3dc-a110268de71f
                front: Ideální cache vs. skutečná cache
                back: Skutečné cache mají asociativitu, nejsou plně asociativní. Skutečné cache nevidí budoucnost, mají LRU.
        -
                uuid: bc29fdf5-d98c-4503-8c47-97882feef63d
                front: Sleator-Tarjanova věta o LRU/OPT strategii
                back: >
                        Ať je posloupnost přístupů [$]s_1, \\ldots s_N[/$], LRU ať má [$]n_{LRU}[/$] stránek, OPT ať má [$]n_{OPT}[/$] stránek.

                        Tvrzení: [$]\\#[/$] LRU výpadků [$]\\leq \\frac{n_{LRU}}{n_{LRU}-n_{OPT}}\\cdot\\#[/$] výpadků OPT [$]+n_{LRU}[/$]

                        Pozorování:
                        Když má LRU výpadek v čase [$]t_1, t_2[/$] na stejné stránce ([$]s_{t_1}=s_{t_2}[/$]),
                        tak mezi [$]t_1[/$] a [$]t_2[/$] přistupuje k [$]n_{LRU}[/$] různým stránkám.

                        Rozsekejme [$]s_{\\*}[/$] na kusy, v nichž v každém je v LRU [$]n_{LRU}[/$] výpadků (až na poslední).
                        V každém se přistupuje k aspoň [$]n_{LRU}[/$] různým stránkám.
                        OPT musí mít v daném úseku aspoň [$]n_{LRU}-n_{OPT}[/$] výpadků, protože na začátku má OPT v sobě nejvýš [$]n_{OPT}[/$] stránek.

                        Tedy: [$]\\#_{LRU}/n_{LRU} \\leq \\lceil \\#_{OPT} / (n_{LRU}-n_{OPT}) \\rceil[/$]

                        Když zvolím 2x větší LRU, bude konstanta nejvýš 2.

