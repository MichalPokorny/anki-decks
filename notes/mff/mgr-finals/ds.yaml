deck: All::Magisterské státnice::Datové struktury
notes:
        -
                uuid: ae5a81b0-dec8-4bd1-bd6b-5f1c8f7fb3eb
                front: Základní vlasnost binárních vyhledávacích stromů
                back: V pořadí zleva doprava v DFS jsou klíče uspořádané od nejmenšího po největší.
        -
                uuid: caf785f4-dcf0-400e-9c72-dd0f8b5b5ba5
                front: Na jaké vlastnosti záleží doba vyhledávání ve vyhl. stromu? Jak se to optimalizuje?
                back: >
                        Na hloubce vrcholů. Systematické vyvažování: AVL/red-black/...; (a,b)-stromy; "dynamicky": splay stromy
        -
                uuid: 017590ba-1c6b-43b3-9454-5641a154476d
                front: >
                        [$] (a,b)[/$]-stromy: význam [$]a[/$], [$]b[/$], invariant
                        <br>
                        Kde jsou hodnoty? Co je ve vnitřních uzlech?
                back: >
                        [$]a\\geq 2[/$], [$]b\\geq 2a-1[/$]
                        <br>
                        Každý vrchol má aspoň [$]a[/$] a nejvýš [$]b[/$] synů ([$]\\in[a;b][/$])
                        <br>
                        Hodnoty jsou v listech. Vnitřní uzly obsahují maxima svých podstromů.
        -
                uuid: eebfb938-29c8-4db5-aedb-9b62c93a96b5
                front: Kolik listů má [$] (a,b) [/$]-strom dané hloubky? Jakou má hloubku, podle množství listů?
                back: >
                        Mezi [$]a^{d-1}[/$] a [$]b^d[/$]. Hloubka: [$]\\log_b n \\leq d \\leq 1 + \\log_a n[/$].
        -
                uuid: abb7a7f3-7173-492b-b118-3e7b6f7ea15b
                front: >
                        [$] (a,b)[/$]-strom -- Insert
                back: >
                        1. Najdi vrchol *v*, pod který patří nový list.<br>

                        2. Pokud má *v* míň než [$]b[/$] synů, přidej pod něj *v* <br>

                        3. Pokud má *v* [$]b[/$] synů, rozštěp ho na dva, co má každý [$] (b+1)/2 [/$] synů. Rekurzivně vlož do otce.
        -
                uuid: 163b97da-16f0-493e-a772-66e7b80956b9
                front: >
                        [$] (a,b)[/$]-strom -- Delete
                back: >
                        1. Pokud otec mazaného listu obsahuje [$]>a[/$] synů, odmaž list a je to.<br>

                        2. Pokud otec spolu s levým nebo pravým sourozencem obsahuje [$]>2a[/$] synů, jednoho přesuň a smaž [$]v[/$]. Zaktualizuj informace o maximech.<br>

                        3. Jinak otce a strýce sluč a rekurzivně pokračuj nahoru.
        -
                uuid: e6660a05-296f-4e06-84bc-2f8c520aff01
                front: >
                        [$] (a,b)[/$]-strom -- Join
                back: >
                        Spojí ztromy [$]T_1[/$], [$]T_2[/$], pokud [$]\\max T_1 < \\min T_2[/$].<br>

                        Ať je [$]T_1[/$] ten vyšší. [$]r=d(T_1) - d(T_2)[/$]<br>

                        Syny kořene [$]T_2[/$] přidej najednou k synům posledního vrcholu na hladině [$]r[/$] ve stromě [$]T_1[/$].<br>
                        Pokud bude mít moc synů, rozštěp ho jako při Insertu. Složitost: [$]\\O(d(T_1) - d(T_2))[/$]
        -
                uuid: 97fefc3c-d1b3-4bc2-a7ab-5acb6e67718f
                front: >
                        [$] (a,b)[/$]-strom -- Split
                back: >
                        Rozdělí strom na dva, jeden s klíči [$]<k[/$], druhý [$]\\geq k[/$].<br>

                        Máme dva zásobníky: jeden pro levé stromy, druhý pro pravé.<br>
                        Postupuj jako při Find, rozděluj přitom na [$]T_L[/$], [$]T_k[/$], [$]T_P[/$].<br>
                        Postupně plň zásobníky. Pak postupně pojoinuj stromy v zásobnících,
                        takže Split bude trvat [$]\\O(\\log n)[/$].
        -
                uuid: b56212a0-6576-40e6-b4ea-850ff2d6561e
                front: >
                        [$] (a,b)[/$]-strom -- amortizovaný počet štěpení a splučování v sekvenci Insertů a Deletů; jaký to má předpoklad?
                back: >
                        [$]\\O(m+\\ell+\\log n)[/$] splitů na [$]m[/$] Insertů,
                        [$]\\ell[/$] Deletů, takže [$]\\O(1)[/$] amortizovaně
                        splitů/insertů za operaci<br>

                        Předpoklad: [$]b\\geq 2a[/$]
        -
                uuid: 34d286ac-489f-42df-89f4-be0f7ec168ab
                front: A-sort a jeho složitost
                back: >
                        Postupně vkládej do [$] (a,b)[/$]-stromu, pak je vypiš během DFS.<br>

                        Drž si prst na poslední vložený prvek, od něj dělej hledání při vkládání dalšího.<br>

                        Celkový čas: [$]\\leq 2 \\sum_{i=1}^n \\log_a |{j\\leq i, x_i < x_j}| + \\O(n)[/$]<br>

                        ([$]\\log[/$] je konkávní)<br>

                        [$$]\\leq 2n \\log_a \\frac{\\sum_i |{j\\leq i, x_i < x_j}|}{n} = \\O(n\\log(F/n))[/$$]

                        [$]F[/$]: počet "inverzí"<br>

                        Alternativně: hledání od nejpravějšího listu [$]\\rightarrow \\leq 1 + \\log_a |\\{j < i+1, x_j > x_i\\}|[/$]
        -
                uuid: cede43cf-fed3-463f-abe4-646bd6fc51aa
                front: Red-black trees -- axiomy
                back: >
                        Každý uzel je červený nebo černý.<br>
                        Červené uzly mohou být syny pouze černých uzlů (nemůže být červený uzel pod červeným).<br>
                        Na každé cestě do listu je stejný počet černých vrcholů.<br>
                        Hodnoty jsou ve vnitřních vrcholech.
        -
                uuid: 121e2648-cfe6-4f4a-8ad3-642a376baae5
                front: Red-black trees -- ekvivalence s [$] (a,b) [/$]
                back: >
                        Ekvivalentní [$] (2,3) [/$]-stromům. Jsou tři možnosti: vrchol je červený a má dva černé syny; je černý a má dva červené syny; je černý a má jednoho červeného syna. To jsou gadgety na 4, 2, 3 syny.
        -
                uuid: b2e3d4a9-a888-45cc-b1ab-182fc1390bc1
                front: Preventativní půjčování a štěpení
                back: >
                        Při insertu preventativně štěp všechno co má [$]b[/$] synů.
                        Při deletu při hledání od kořene uprav každý vrchol s [$]a[/$]
                        syny buď přidáním syna ze sourozence nebo slitím se sourozencem.
        -
                uuid: 781d7242-25bd-4b2a-8862-f80a6ebc397e
                front: Vlastnosti splay stromu - maximální, amortizovaná cena vkládání
                back: >
                        Na operaci: až [$]\\O(n)[/$]

                        Cena za [$]m[/$] operací, [$]n[/$] vložených prvků: [$]\\O(m\\log n+n\\log n)[/$]
        -
                uuid: f0795afe-ab1d-4293-a1ad-e6f88a9c80f5
                topic: Splay stromy
                front: Operace Splay -- případy
                back: >
                        [$]Splay(x)[/$]

                        Případy:

                        A:
                        <pre>
                               z              x
                              / \            / \
                             y   .          .   y
                            / \        ==>     / \
                           x   .              .   z
                          / \                    / \
                         .   .                  .   .
                        </pre>

                        B:
                        <pre>
                               z                   x
                              / \                /  \
                             y   .              y    z
                            / \        ==>     / \  / \
                           .   x              .   ..   .
                              / \
                             .   .
                        </pre>

                        C: (u kořene)
                        <pre>
                             y                     x
                            / \                   / \
                           x   .     ==>         .   y
                          / \                       / \
                         .   .                     .   .
                        </pre>
        -
                uuid: dc66b323-9313-4e90-9de3-e00034c2cf8e
                topic: Splay stromy
                front: Insert
                back: >
                        Vysplayuj nahoru poslední vrchol na cestě k chybějícímu [$]x[/$].

                        Podrozděl levou nebo pravou hranu z vysplayovaného kořene novým vrcholem [$]x[/$].
        -
                uuid: a95b34fc-04cd-4672-aaa9-ed11305aea42
                topic: Splay stromy
                front: Delete
                back: >
                        Vysplayuj nahoru vrchol co chci odebrat.
                        Odeber ho, nahraď ho nejmenším/největším z pravého/levého podstromu.
        -
                uuid: 5071f3a5-9735-46ce-90d8-e13d3e9d9eea
                topic: Splay stromy
                front: Amortizovaný čas na Splay -- definice - skutečný čas a potenciál před a po operaci
                back: >
                        [$]t = a + \\Phi(T') - \\Phi(T)[/$],<br>
                        kde [$]a[/$] je skutečný čas, [$]\\Phi[/$] je potenciál, [$]t[/$] je amortizovaný čas<br>
        -
                uuid: 3e6385c5-e3b9-400c-9bc1-f6cf01561dfc
                topic: Splay stromy
                front: Definice potenciálu
                back: >
                        [$$]\\Phi(t) := \\sum_{x\\in T}r(x); r(x) := \\log_2(\\text{počet vrcholů pod}\\ x)[/$$]
        -
                uuid: 45db7dff-0f55-44f9-964d-65a5a69dd29a
                topic: Splay stromy
                front: Teleskopická suma porovnávající amortizovaný čas a skutečný čas
                back: >
                        Pro amortizovaný čas:
                        [$$]\\sum_i t_i = (\\sum_i a_i) + \\Phi(T_m)-\\Phi(T_0)[/$$]<br>

                        Takže pro skutečný čas:
                        [$$]\\sum_{i=1}^m a_i = \\sum_{i=1}^m t_i + \\Phi(T_0) - \\Phi(T_m) \\leq \\sum_{i=1}^m t_i + \\Phi(T_0)[/$$]
        -
                uuid: 5af4b439-60f4-4a7a-a103-ac9ad8cd2b02
                topic: Splay stromy
                front: Co chci dokázat o času na jeden dvourotační krok?
                back: >
                        Že jeho amortizovaný čas (tedy změna plus skutečný čas [$]\\Phi(T')-\\Phi(T)[/$]) je:<br>
                        Pro rotace vevnitř (případ [$]x\\rightarrow y\\rightarrow z[/$], [$]x\\leftarrow y\\rightarrow z[/$]): [$]t\\leq 3(r'(x)-r(x))[/$].
                        Pro rotaci u kořene: [$]t\\leq 3(r'(x)-r(x)) + 1[/$].
        -
                uuid: 8d4b7b9b-26fa-4fb5-aca4-3f8af1d65cf3
                topic: Splay stromy
                front: K čemu se bude hodit omezení na amortizovaný čas na dvourotační kroky?
                back: >
                        Na krok je čas [$]\\leq 3(r'(x)-r(x))[/$], plus 1 za rotaci u kořene.<br>
                        To se postupným splayováním vyteleskopuje na [$]1+3(r(v)-r(x))[/$], kde [$]v[/$] je kořen stromu.<br>
                        To je nejvýš [$]\\Theta(\\log N)[/$].
        -
                uuid: 041041da-2e5b-4696-95c9-94c1e7f4855b
                topic: Splay stromy
                markdown: false
                front: >
                        Amortizovaný čas na Splay -- na případ [$]z\searrow y\searrow x \Longrightarrow z\swarrow y\swarrow x[/$]
                back: >
                        [latex]
                        \begin{align*}
                                t := & a+\Phi(T')-\Phi(T) = &
                        \\         = & \underbrace{2}_{Rotace} + r'(x) - r(x) + r'(y) - r(y) + r'(z) - r(z) = & [r(z)=r'(x)]
                        \\         = & 2 - r(x) + r'(y) - r(y) + r'(z) \leq & [r'(y) \leq r'(x); r(y)\geq r(x)]
                        \\      \leq & 2 - r(x) + r'(x) - r(x) + r'(z) &
                        \\         = & 2 + r'(x) - 2r(x) + r'(z) &
                        \end{align*}
                        [/latex]
                        <br>
                        Pozorování: [$]2 \leq 2r'(x) - r(x) - r'(z)[/$]<br>
                        Tedy: [$$]t\leq 2+r'(x)-2r(x)+r'(z) \leq 3r'(x)-3r(x)[/$$]
        -
                uuid: 065f235b-8a51-475a-a1b1-2a56296b940e
                topic: Splay stromy
                markdown: false
                front: Amortizovaný čas na Splay -- na případ [$]z\searrow y\swarrow x \Longrightarrow z\nearrow x\nwarrow y[/$]
                back: >
                        [latex]
                        \begin{align*}
                                t := & a+\Phi(T')-\Phi(T) = &
                        \\         = & \underbrace{2}_{Rotace} + r'(x) - r(x) + r'(y) - r(y) + r'(z) - r(z) = & [r(z)=r'(x)]
                        \\         = & 2 - r(x) + r'(y) - r(y) + r'(z) \leq & [r(y) > r(x)]
                        \\      \leq & 2 - 2r(x) + r'(y) - r'(z) &
                        \end{align*}
                        [/latex]
                        <br>

                        Pozorování: [$]2\\leq 2r'(x)-r'(y)-r'(z)[/$]<br>

                        Tedy: [$$]t \\leq 2r'(x)-2r(x)=2(r'(x)-r(x))\\leq 3(r'(x)-r(x))[/$$]
        -
                uuid: cd420f77-33c2-4660-8c81-eefc5cc04e1b
                topic: Splay stromy
                front: Amortizovaný čas na Splay -- na případ [$]x\\rightarrow y[/$] v kořeni
                back: >
                        [$$]t\\leq 1+r'(x)-r(x)+r'(y)-r(y)[/$$]

                        Poz.: [$]r'(y)<r(y)[/$], [$]r'(x)-r(x)>0[/$]

                        [$$]t \\leq 1+r'(x)-r(x) \\leq 1+3(r'(x)-r(x))[/$$]
        -
                uuid: 7738e830-27af-432c-9f98-4266eae390e8
                front: Haldy -- obecný interface
                back: >
                        Insert, Min, DeleteMin
        -
                uuid: 98f1108a-eb48-4c63-ba19-aef0d126a539
                topic: Regulární halda
                front: Invariant, uložení do pole
                back: >
                        Invariant: Prvek je menší než všechny pod ním.
                        Pod [$]i[/$] jsou prvky [$]2i[/$], [$]2i+1[/$].
        -
                uuid: d77b8f43-105e-4074-8728-893e94fc4584
                topic: Regulární halda
                front: Algoritmus Insert
                back: >
                        Přidej prvek na konec pole. Bublej ho směrem ke kořeni,
                        dokud je porušena podmínka, že otec je menší než syn.
        -
                uuid: 8a30657b-6486-43b4-b69c-4acb6d6c7777
                front: Regulární halda -- Delete
                back: >
                        Poslední prvek přesuň do prvního, bublej s menším ze synů směrem dolů dokud je otec větší než syn.
        -
                uuid: 53dbd39b-fe32-406d-9da8-b7d3f206bd0b
                front: Regulární halda -- časy
                back: >
                        Insert, DeleteMin: [$]\\O(\\log n)[/$], Min: [$]\\O(1)[/$]
        -
                uuid: a117f9b8-e1b0-4e51-8ed8-e67f2c8572d0
                front: Binomiální halda -- struktura
                back: >
                        Soubor haldově uspořádaných stromů velikostí [$]2^k[/$].
                        Pamatujeme si, který obsahuje minimální prvek.

                        Zbrklá varianta: nejvýše jeden strom dané varianty.

                        Líná varianta: bez omezení na počet stromů stejné velikosti.

                        Jeden binomiální strom obsahuje kořen a hned pod ním menší binomiální stromy všech menších velikostí.
        -
                uuid: f4b71aef-78b4-46b1-a788-42d1dc6620fc
                front: Eager binomiální halda -- Insert
                back: >
                        Přidej nový haldový strom velikosti 1,
                        postupně slívej dokud existují dva stromy stejné velikosti.
                        Aktualizuj ukazatel na strom s minimálním prvkem.
        -
                uuid: f90fa989-ff96-41b1-8a27-0eeaaa17cc8d
                front: Eager binomiální halda -- DeleteMin
                back: >
                        Odřízneme kořen stromu s minimálním prvkem. Rozpadne se na [$]i[/$] stromů velikosti [$]2^0, 2^1, \\ldots 2^{i-1}[/$].
                        Postupně slívej jako při Insertu.
        -
                uuid: f60d57a1-990f-4c50-8992-f9a82e172a74
                front: Eager binomiální halda -- složitosti
                back: >
                        Insert [$]\\O(\\log n)[/$], Min [$]\\O(1)[/$], DeleteMin [$]\\O(\\log n)[/$].
                        <br><br>
                        Ale [$]n[/$] insertů trvá jenom [$]\\O(n)[/$] (amortizací přes inkrement).
                        (Amortizovaně [$]\\O(1)[/$] na Insert dokud se neprovede DeleteMin.)
        -
                uuid: 3badd3b1-40d5-4e0c-925a-3126f13208cf
                topic: Líná binomiální halda
                front: Algoritmus pro Insert
                back: Vytvoř nový strom velikosti 1 a aktualizuj odkaz na minimum.
        -
                uuid: baad0a81-0faa-4a86-8dd4-552e0aa815d6
                topic: Líná binomiální halda
                front: Algoritmus pro DeleteMin
                back: >
                        Odřízni kořen stromu s minimálním prvkem. Slévej stromy stejné velikosti dokud to jde.
        -
                uuid: 00bd62d4-b7b8-461d-a215-3ac8f38335b2
                topic: Líná binomiální halda
                front: Složitosti, důkazy
                back: >
                        Insert [$]\\O(1)[/$], Min [$]\\O(1)[/$], DeleteMin [$]\\O(n)[/$], ale amortizovaně [$]\\O(\\log n)[/$]<br>

                        Potenciál: [$]\\Phi(T) = C \\cdot [/$] počet stromů v haldě<br>

                        Insert: [$]\\leq C + \\Phi(T')-\\Phi(T) = C[/$]<br>

                        DeleteMin: [$]\\leq C \\cdot [/$] počet stromů [$]+\\Phi(T')-\\Phi(T)\\leq C\\cdot\\log n = \\O(\\log n)[/$]
        -
                uuid: aa2bd2dc-0887-4116-b0fd-7920f52db5b5
                front: Model externí paměti -- notace
                back: >
                        [$]M[/$]: velikost paměti<br>

                        [$]B[/$]: velikost přenášených bloků<br>

                        [$]M/B[/$]: počet bloků v paměti
        -
                uuid: fc258cff-8cef-495b-a6ca-69afbc5252f9
                front: Model externí paměti -- složitost sekvenčního čtení
                back: >
                        [$$]\\lceil N/B \\rceil + 1[/$$]
        -
                uuid: c9501f8e-cfb7-4cda-b76c-997165ec1cdb
                front: Model externí paměti -- složitost binárního vyhledávání
                back: >
                        [$$]\\log N - \\log B[/$$]
        -
                uuid: 421b4c33-4f9e-4ceb-8ae5-55590e3be666
                front: Model externí paměti -- transpozice matice, za jaké podmínky to funguje. Co naivní algoritmus?
                back: >
                        Když [$]M>B^2[/$], jde udělat algoritmus s [$]N^2/B[/$] přenosy (optimální).
                        Transponuj po podmaticích velikosti [$]B\\times B[/$].<br>
                        Naivní algoritmus chce [$]N^2[/$] přenosů (pokud [$]\\frac{M}{B}<N[/$]).
        -
                uuid: b0008716-72b5-43cb-a275-0cc8975b732e
                front: Cache-oblivious algoritmy
                back: >
                        Algoritmus je navržený bez známého [$]M[/$], [$]B[/$].
                        Analyzujeme s tím, že to jsou neznámé.
        -
                uuid: 02c3fb00-23d9-4011-869f-9287b94fb132
                front: Transpozice matice cache-obliviously. Jaký má předpoklad? Jakou má složitost?
                back: >
                        Rekurzivně po čtvrtinách. Předpoklad: [$]M\\geq B^2[/$] (tall cache assumption)

                        Jakmile se dostanu na velikost [$]B\\times B[/$], tak jedna transpozice trvá [$]B[/$] přenosů. Takových matic je [$]N^2/B^2[/$]. [$]\\O(N^2/B^2 \\cdot B)=\\O(N^2/B)[/$] I/O operací.
        -
                uuid: f7be2627-47a5-4c5e-bf80-bceaf95803dc
                front: van Emde-Boasovo uspořádání
                back: >
                        Useknu strom v půlce výšky. Nahoře je [$]\\sqrt{N}[/$] prvků, dole je [$]\\sqrt{N}[/$] stromů, každý velký [$]\\sqrt{N}[/$]. Uložím je za sebe.
                        Počet I/O operací: [$]\\frac{\\log n}{\\log \\sqrt{B}}=2\\log_B N[/$]

                        To je zlepšení proti binárnímu vyhledávání ([$]\\log N - \\log B[/$]).
        -
                uuid: f71b5948-d157-4aec-b0b5-4aa6544b839f
                front: Třídení -- optimální cache-oblivious složitosti
                back: >
                        Za předpokladu [$]M\\geq B^2[/$] jde [$]\\O(n\\log n)[/$] operací, [$]\\O(N/B \\log_{M/B}[N/B])[/$] I/O
        -
                uuid: cae253c8-de58-49f7-b3dc-a110268de71f
                front: Ideální cache vs. skutečná cache
                back: Skutečné cache mají asociativitu, nejsou plně asociativní. Skutečné cache nevidí budoucnost, mají LRU.
        -
                uuid: bc29fdf5-d98c-4503-8c47-97882feef63d
                front: Sleator-Tarjanova věta o LRU/OPT strategii
                markdown: false
                back: >
                        Ať je posloupnost přístupů [$]s_1, \ldots s_N[/$], LRU ať má [$]n_{\mathrm{LRU}}[/$] stránek, OPT ať má [$]n_{\mathrm{OPT}}[/$] stránek.<br>

                        Tvrzení: [$]f_{\mathrm{LRU}} \leq \frac{n_{LRU}}{n_{LRU}-n_{OPT}}\cdot f_{\mathrm{OPT}}+n_{\mathrm{LRU}}[/$]<br><br>

                        Pozorování:
                        Když má LRU výpadek v čase [$]t_1, t_2[/$] na stejné stránce ([$]s_{t_1}=s_{t_2}[/$]),
                        tak mezi [$]t_1[/$] a [$]t_2[/$] přistupuje k [$]n_{\mathrm{LRU}}[/$] různým stránkám.<br>

                        Rozsekejme [$]s_{\*}[/$] na kusy, v nichž v každém je v LRU [$]n_{\mathrm{LRU}}[/$] výpadků (až na poslední).
                        V každém se přistupuje k aspoň [$]n_{\mathrm{LRU}}[/$] různým stránkám.
                        OPT musí mít v daném úseku aspoň [$]n_{\mathrm{LRU}}-n_{\mathrm{OPT}}[/$] výpadků, protože na začátku má OPT v sobě nejvýš [$]n_{\mathrm{OPT}}[/$] stránek.<br>

                        Tedy: [$]f_{\mathrm{LRU}}/n_{\mathrm{LRU}} \leq \lceil f_{\mathrm{OPT}} / (n_{\mathrm{LRU}}-n_{\mathrm{OPT}}) \rceil[/$]<br>

                        Když zvolím 2x větší LRU, bude konstanta nejvýš 2.
        -
                uuid: 521fe3ca-0fe0-4e1f-ad8b-f7a2868fbd1c
                topic: Hashování
                front: Jaký problém řeší, a obecně jak?
                back: >
                        Máme velké univerzum [$]U[/$], chceme reprezentovat [$]S\\subseteq U[/$], [$]|S|=n[/$],
                        operace Find, Insert, (Delete).
                        <br>
                        Triviálně bychom mohli použít pole velikosti [$]|U|[/$].
                        <br>
                        Vybereme funkci [$]h:U\\imp\\{1\\ldots m\\}[/$],
                        kde [$]m \\ll |U|[/$].
        -
                uuid: c71f666f-87cf-4e3a-9a82-fdd34870f868
                topic: Hashování
                front: Způsoby řešení kolizí -- jen názvy
                back: >
                        Separované řetězce, srůstající řetězce, s pomocným polem,
                        lineární přidávání, dvojité hashování
        -
                uuid: e09b4e0b-73ad-4c1a-9fb5-b4fc5b5be227
                topic: Hashování
                front: Řešení kolizí přes separované řetězce
                back: V každém kyblíku je vyhledávací strom
                include_reverse: true
        -
                uuid: 375fb09c-1fd8-4f9c-9fd4-e2af45d3c60a
                topic: Hashování
                front: Srůstající řetězce (a dva podzpůsoby)
                back: >
                        Každý kyblík obsahuje jeden prvek a
                        volitelně jeden ukazatel, který tvoří jednosměrný
                        spojový seznam.
                        Když přidám nový ukazatel, přidám ho buď na konec
                        seznamu (LICH), nebo za první prvek seznamu (EICH).
                include_reverse: true
        -
                uuid: cc8b7849-4bef-452a-831c-4fa1840cf780
                topic: Hashování
                front: S pomocným polem
                back: >
                        V kyblíku je místo na prvek a ukazatel.
                        Ukazatele ukazují do pomocného pole, které může ukazovat dál.
                        Jakmile dojde pomocné pole, začnu ukládat přetékající prvky
                        do hlavního pole.
        -
                uuid: 3d2bb991-29ac-4946-ae79-9ac263d37cde
                topic: Hashování
                front: Jak funguje lineární přidávání
                back: Prvek vkládám na nejbližší volnou pozici za jeho kyblík.
                include_reverse: true
        -
                uuid: e0960c1a-6420-4b43-8f99-dad5a9dcae79
                topic: Hashování
                front: Dvojité hashování
                back: Zkouším postupně pozice [$]h_1(x)+i\\cdot h_2(x)[/$]
        -
                uuid: b287950b-c81e-4ddd-b13e-6c8b7b2d79fa
                topic: Hashování
                front: Co vyžaduje dvojité hashování?
                back: >
                        Když je [$]m[/$] kyblíků a pozice se počítá
                        [$]h_1(x)+i\\cdot h_2(x)[/$], je potřeba aby [$]h_2(x)[/$]
                        bylo nesoudělné s [$]m[/$] (to platí např. když
                        [$]m\\in P[/$] a [$]h_2(x)\\in\\{1,\\ldots m-1\\}[/$].
        -
                uuid: 5fefc52d-1b67-4396-8cdf-5789671300b5
                topic: Hashování
                front: Jak se dělá Delete?
                back: >
                        Je problematický.<br>
                        Jako trik můžu označit smazané prvky a při Insert je
                        znovu použít. Pokud jich bude příliš mnoho označených,
                        udělám přehashování.
        -
                uuid: ac827d29-d92c-464a-af33-fb9c17cfedd1
                topic: Hashování
                front: Balls & bins - pravděpodobnost, že koš je prázdný
                back: >
                        [$]n[/$] košů a [$]n[/$] míčků, které házím náhodně.
                        <br>
                        [$$]P[\\text{kos je prazdny}]=\\left(1-\\frac{1}{n}\\right)^n\\rightarrow_{n\\rightarrow\\infty} \\frac{1}{e}[/$$]
        -
                uuid: 468efc83-6992-449e-a0a1-b17b35267089
                topic: Hashování
                front: Balls & bins - pravděpodobnost, že koš obsahuje [$]k[/$] míčků
                back: >
                        [$$]P[\\text{kos ma}\\ n\\ \\text{micku}]=
                                {n\\choose k} \\frac{1}{n^k} \\left(1-\\frac{1}{n}\\right)^{n-k} \\approx_{k\\ll n} \\frac{n^k}{k!} \\cdot \\frac{1}{n^k} \\cdot \\frac{1}{e} = \\frac{1}{e \\cdot k!}[/$$]
        -
                uuid: ac807671-0264-404e-b631-1cb43628151d
                topic: Hashování
                front: Balls & bins - jaké je maximum v libovolném košíku?
                back: >
                        S velkou pravděpodobností [$]\\Theta(\\log n/\\log \\log n)[/$].
                        <br>
                        [$]n! < n^n[/$]. Vezmi [$]x=\\log n/\\log\\log n[/$].
                        [$]x^x < n[/$], pokud [$]x \\log x < \\log n[/$].<br>
                        [$$] (x \\log x) = (\\frac{\\log n}{\\log\\log n})\\log(\\frac{\\log n}{\\log\\log n}) < \\log x[/$$]<br>
                        <br>
                        Pravděpodobnost, že v jednom koši je [$]k[/$] míčků, je [$]\\Theta(\\frac{1}{k!})[/$],
                        pravděpodobnost, že v jednom koši je [$]\\geq k[/$], je [$]\\Theta(\\frac{1}{k!})[/$].
                        <br>
                        Pravděpodobnost, že v žádném koši není [$]\\geq k[/$], je [$]\\geq n/k![/$],
                        takže z toho vyjde že pro [$]k=\\Theta(\\log n/\\log\\log n)[/$] je to konstantní pravděpodobnost.
        -
                uuid: 3cb51b71-608b-49d3-96b9-ee2e796bfac9
                topic: Hashování
                front: Proč nás zajímá balls & bins?
                back: >
                        Protože to říká že při náhodně zvolené hashovací funkci 
                        bude maximální velikost kyblíku [$]\\Theta(\\log n/\\log\\log n)[/$].
        -
                uuid: 935989fe-baee-45f7-a1c1-e4aefdf82607
                topic: Hashování
                front: Analýza lineárního přidávání
                markdown: false
                back: >
                        Předpokládám, že [$]h[/$] přiděluje prvky zcela náhodně.
                        <br>
                        [$]p_{k,s}[/$]: pravděpodobnost, že nejbližší volná pozice je po [$]k[/$] prvcích
                        a před [$]h(x)[/$] je dalších [$]s[/$] prvků.
                        <br>
                        [latex]
                        \begin{align*}
                        p_{k,s} & = & {n\choose {k+s}} \cdot \left(\frac{k+s}{m}\right)^{k+s} \leq &
                        \\      & \leq & \frac{n^{k+s}}{(k+s)!} \cdot \frac{(k+s)^{k+s}}{m^{k+s}} = &
                        \\      & = & \frac{n^{k+s}}{m^{k+s}}\cdot\frac{(k+s)^{k+s}}{(k+s)!} = & \text{Stirling:} a!\approx \sqrt{2\pi a}(a/e)^a
                        \\      & = & (n/m)^{k+s} \cdot \frac{1}{\sqrt{k+s}} \cdot e^{k+s} \cdot \frac{1}{\sqrt{2\pi}} &
                        \end{align*}
                        [/latex]
                        <br>
                        Zvolím [$]m\geq 3n[/$], protože [$]e\approx 2.718\ldots[/$].
                        <br>
                        [$$]\ldots (e/3)^{k+s} \cdot \frac{1}{\sqrt{(k+s)2\pi}}[/$$]
                        <br>
                        Očekávaná doba vkládání:
                        [$$]\leq \sum_{k\geq 1}k\cdot Pr[\text{hledani potrva cas}\ k]\leq\sum_{k\geq 1} k\cdot\underbrace{\sum_{s\geq 0} (e/3)^{k+s} \cdot \frac{1}{\sqrt{(k+s)2\pi}}}_{\leq \mathcal{O}((e/3)^k)} = \mathcal{O}(1)[/$$]
        -
                uuid: 0339b66e-85a4-4d31-b828-4675c05308b1
                topic: Hashování
                front: Očekávání maximální zaplnění koše při balls & bins, když zvolím náhodně dva koše a hodím do toho prázdnějšího
                back: >
                        [$$]\\mathcal{O}(\\log\\log n)[/$$]
        -
                uuid: a07d81f9-50a8-40f3-979f-2af29909f06a
                topic: Kukaččí hashování
                front: Jak funguje?
                back: >
                        Mám dvě hashovací funkce, [$]x[/$] je buď v [$]h_1(x)[/$], nebo [$]h_2(x)[/$].
                        <br>
                        Insert:
                        [$]pos\\leftarrow h_1(x)[/$].
                        Opakuj n-krát: pokud je kyblík [$]pos[/$] zaplněný,
                        vyměň [$]x[/$] a [$]T[pos][/$], vyber [$]x[/$] jako druhý hash.
                        Jestli to doběhne a furt držíš prvek, přehashuj.
        -
                uuid: c74711df-85a0-43a9-a527-3f63dab19f6e
                topic: Kukaččí hashování
                front: Pro jaké [$]m[/$] funguje dobře?
                back: >
                        [$]m\\approx 2.3n[/$], ale analýzu ukážu pro [$]m=6n[/$].
        -
                uuid: 427e6fb9-f7ad-4c90-8142-2fcbf25c0a8f
                topic: Kukaččí hashování
                front: Důkaz očekávaného počtu přehašování za Inserty
                back: >
                        [$]m=6n[/$].
                        <br>
                        Tvrzení: Pravděpodobnost, že pro náhodně zvolené funkce
                        obsahuje kukačkový graf cyklus, je [$]\leq 1/2[/$].
                        <br>
                        Lemma: Pravděpodobnost, že pro náhodné hf jsou pozice
                        [$]i,j[/$] spojeny cestou délky [$]\ell[/$] je
                        [$]\leq (2n/m)^\ell \cdot \frac{1}{m} \leq \frac{1}{3^\ell}\cdot\frac{1}{m}[/$].
                        <br>
                        Důkaz lemmatu:<br>
                        [latex]
                        \begin{align*}
                        P[d(i,j)=l] & \leq & P[e x_{1,\ldots \ell}, i_{1,\ldots \ell-1}:
                                h(x_1)=\\{i,i_1\\} \wedge \ldots h(x_\ell)=\\{i_{\ell-1},j\\}] \leq \\\\\\\\
                                    & \leq & \underbrace{2^\ell}_{\text{parita}} \cdot n \cdot (n-1) \cdot \ldots \cdot (n-\ell+1) \cdot m^{l-1} \cdot m^{2(n-\ell)} / m^{2n} \leq \\\\\\\\
                                    & \leq & \frac{2^\ell}{m^{2\ell}} \cdot n^\ell \cdot m^{\ell-1} = \\left(\frac{2n}{m}\\right)^\ell \cdot \frac{1}{m}
                        \end{align*}
                        [/latex]
                        <br>
                        Důkaz tvrzení:
                        <br>
                        [$$]P[i\text{ je v cyklu delky }\ell]\leq\frac{1}{3^\ell}\frac{1}{m}[/$$]<br>
                        [$$]P[i\text{ je v cyklu}]\leq\sum_{\ell\geq 1}\frac{1}{3^\ell}\cdot\frac{1}{m}\leq\frac{1}{2m}[/$$]<br>
                        [$$]P[\text{existuje cyklus}]\leq\frac{1}{2}[/$$]
                        <br>
                        Očekávaný počet přehashování je tedy [$]\leq 1[/$] na [$]n[/$] insertů.
        -
                uuid: 049eba81-3ab3-41dd-ad0a-5b4ede0ba8c0
                topic: Kukaččí hashování
                front: Důkaz konstantního času na Insert
                markdown: false
                back: >
                        (Za předpokladu, že není cyklus.)
                        <br>
                        Očekávaná doba:
                        [$$]\leq \sum_{\ell\geq 1}\ell\cdot P[\text{z}\ i\ \text{vede cesta delky}\ell]\leq\sum_{\ell\geq 1}\ell\cdot(\frac{1}{3^\ell}\cdot\frac{1}{m})\cdot m\leq O(1)[/$$]
        -
                uuid: 46f606f8-0e32-430e-a048-f1fae5219434
                topic: Kukaččí hashování
                front: Rychlejší zaříznutí Insertu
                back: >
                        Jakmile mám třeba [$]2\\log n[/$] kroků, začnu už
                        přehashovávat (tak dlouhá cesta je nepravděpodobná).
        -
                uuid: d52ea10a-0954-4378-9970-11cbc6f11e83
                front: Proč chceme vybírat hashovací funkci netriviálně?
                back: >
                        Protože data nejsou většinou uniformní a nezávislá.
                        Kdyby byly distribuovány uniformně nezávisle, libovolná
                        funkce co by mapovala do stejně velkých bucketů by
                        fungovala dobře.
        -
                uuid: c1ffa339-6cfd-4dcb-8a54-f5b394d260d8
                front: Proč prostě nevybereme náhodnou hashovací funkci?
                back: >
                        Protože by potřebovala [$]|U|\\cdot\\log m[/$]
                        bitů na popis, to je moc.
        -
                uuid: 7d120cf9-d36a-4458-acb0-d3112c9f85fe
                front: Co je to univerzální hashovací systém?
                back: >
                        Pro každé pevné [$]x,y[/$]: [$]P_{h\in H}[h(x)=h(y)]=\frac{1}{m}[/$]
                        <br>
                        Neboli: pravděpodobnost kolize dvou prvků je stejná
                        jako u zcela náhodné funkce.
        -
                uuid: 52cb81e7-a118-4769-b2ef-e509bbaa8ad5
                front: Co je to [$]k[/$]-univerzální hashovací systém (resp., po [$]k[/$] nezávislá hashovací funkce)?
                back: >
                        Pro libovolná [$]x_1,\\ldots x_k\\in U, a_1,\\ldots a_k\\in [m][/$]:
                        [$]P_{h\\in H}[h(x_1)=a_1\\wedge\\ldots\\wedge h(x_k)=a_k]=1/m^k[/$]
        -
                uuid: aecfe9c1-4f48-4a72-9811-affb44735f47
                front: Příklady 2-univerzálních hashovacích systémů
                markdown: false
                back: >
                        <ul>
                        <li> Hashování [$] (ax+b)\bmod m[/$].
                        <li> Maticové násobení.
                        <li> Hashování konvolucí.
                        <li> Hashování multiply-shift.
                        <li> Vektory.
                        </ul>

        -
                uuid: 142132d5-e801-478c-ad31-62242ad61c7b
                front: Hashování [$] (ax+b)\\bmod m[/$] a vlastnosti
                back: >
                        [$]m[/$] prvočíslo, [$]H=\\{h_{a,b}:a,b\in [m]\\}[/$],
                        [$]h_{a,b}(x)=(ax+b) \\bmod m[/$]<br>
                        Potřebuje dělení. Je 2-univerzální.
        -
                uuid: f41af809-04ef-4d51-8e33-64159e4001b7
                front: Hashování násobením matic a vlastnosti
                back: >
                        [$]h:\\{0,1\\}^w\\rightarrow\\{0,1\\}^k[/$],
                        [$]H=\\{h_{A,b}, A\\in\\{0,1\\}^{k\\times w},b\\in\\{0,1\\}^k\\}[/$],
                        [$]h_{A,b}(x)=Ax+b[/$], kde maticové násobení je nad [$]GF(2)[/$],
                        popis potřebuje [$]k\\cdot W+k[/$] bitů
                        <br>
                        Maticové násobení je nepraktické. Je 2-univerzální.
        -
                uuid: debfbd21-8f66-48f2-a8e9-f69f99762618
                front: Hashování konvolucí a vlastnosti
                markdown: false
                back: >
                        [$]w,k\in \N, h:\{0,1\}^w\rightarrow\{0,1\}^k[/$],
                        [$]H=\{h_{a,b}:a\in\{0,1\}^{w+k-1},b\in\{0,1\}^b\}[/$].
                        [$] (h_{a,b}(x))_j=b_j+\sum_{i=1}^w a_{i+j-1} x_i[/$]
                        <br>
                        Konvoluce je nepraktická. Je 2-univerzální.
        -
                uuid: 54210963-0024-487a-a312-3fd5eee08e62
                front: Hashování multiply-shift a vlastnosti
                markdown: false
                back: >
                        [$]h:\{0,1\}^w\rightarrow\{0,1\}^k[/$],
                        [$]a,b\in\{0,1\}^{w+k-1}[/$]<br>
                        [$$]h_{a,b}(x)=[(ax+b)\gg w-1)]_{1\ldots k}[/$$] -- vyber nejnižší bity
                        (+,* nad celými čísly)
                        <br>
                        <br>
                        Je rychlé, nepotřebuje dělení, stačí jedno násobení. Je 2-univerzální.
                        <br>
                        Zobecnění: [$][ax+b]_{w'-k+1,\ldots w'}[/$]
        -
                uuid: 849ad267-6f90-4c38-b71c-d3f7fc9e3c97
                front: Hashování vektory
                markdown: false
                back: >
                        [$]h:\{0,1\}^{w\times d}\rightarrow\{0,1\}^k[/$], kde [$]w'\geq w+k-1[/$].
                        <br>
                        [$$]H=\{h_{a_{0,1,\ldots d-1},b}: a_{0,\ldots d-1},b\in\{0,1\}^{w}\}[/$$]
                        <br>
                        [$$]h(x_0,\ldots x_{d-1})=[(\sum a_i x_i) + b]_{w-k+1,\ldots w'}[/$$]
                        (výběr bitů)
        -
                uuid: f93cafa0-b68c-40b8-bac5-b0e103d37916
                front: Hashování vektory - vychytávky
                markdown: false
                back: >
                        Když je [$]d[/$] sudé, jde použít k ušetření násobení:
                        [$$]h(x_0,\ldots x_{d-1})=[(\sum_{i\in\{0,\ldots d/2-1\}} (a_{2i}+x_{2i+1})(a_{2i+1}+x_{2i})) + b][/$$]
                        <br>
                        Pokud chci hashovat vektory proměnné délky [$]d'<d[/$], kde [$]d'[/$] je sudé:
                        [$$]h(x_0,\ldots x_{d'-1})=[(\sum_{i\in\{0,\ldots d'/2-1\}} (a_{2i}+x_{2i+1})(a_{2i+1}+x_{2i})) + a_{d'}]_{w'-k+1,\ldots w'}[/$$]
        -
                uuid: c317b366-ac24-4ebb-9b43-2cd34dd2fe4f
                front: Hashování řetězců - definice
                back: >
                        Vyberu [$]p\\in P (p\\geq |U|)[/$],
                        [$]a\\in\\{0,\\ldots p-1\\}[/$].
                        <br>
                        Vstup: [$]x_0,\\ldots x_{d-1}\\in U[/$].
        -
                uuid: 5896cca5-4819-470d-95d0-50f221d780a7
                front: Hashování řetězců - pravděpodobnost kolize a důkaz
                back: >
                        [$$]h_a(x_0,\\ldots x_{d-1})=\\sum_{i=0}^{d-1}x_i\\cdot a^i \\bmod p[/$$]
                        <br>
                        Věta: když [$]\\overline{x}\\neq\\overline{y}[/$] stejné délky,
                        tak [$]P_a[h_a(\\overline{x})=h_a(\\overline{y})]\\leq d/p[/$].
                        <br>
                        Důkaz: dva různé polynomy stupně [$]\\leq d-1[/$] se mohou shodovat
                        nejvýše v [$]d[/$] bodech.
        -
                uuid: c9a1a95c-fc5b-400d-ba9b-0a6295cda04c
                front: Hashování řetězců - spojení co dá malou pravděpodobnost kolize
                back: >
                        [$]h_a[/$] jde složit s hašovací funkcí [$]\\{0,\\ldots p-1\\}\\rightarrow\\{0,\\ldots m-1\\}[/$]:
                        [$$]h_{a,b,c\\in\\{0,\\ldots p-1\\}} = ((a(\\sum_{i=0}^{d-1} x_i c^i)+b)\\bmod p)\\bmod m[/$$]
                        <br>
                        Pokud [$]d<p/m[/$], tak je pst. kolize [$]\\leq 2/m[/$].
        -
                uuid: 0b8ea909-fb00-43df-836c-4ed075aa9f69
                front: Tabulkové hashování a jeho vlastnosti
                back: >
                        Zvolím [$]x_0,\\ldots x_{d-1}\\in [m][/$],
                        náhodné tabulky [$]T_0,\\ldots T_{d-1}: [m]\\rightarrow\\{0,1\\}^\\ell[/$],
                        výstup je [$]T_0[x_0]\\oplus \\ldots T_{d-1}(x_{d-1})[/$]
                        (XOR po bitech).
                        <br>
                        Je 2-univerzální.
        -
                uuid: a35d77b3-acf6-4133-8d01-69c2005d42a8
                front: 5-univerzální tabulkové hashování
                back: >
                        [$]x_0,x_1\\in [m][/$],
                        náhodné tabulky [$]T_0,T_1: [m]\\rightarrow\\{0,1\\}^\\ell[/$],
                        [$]T_2:[2m]\\rightarrow\\{0,1\\}^\\ell[/$].<br>
                        Výsledek: [$]T_0[x_0]\\oplus T_1[x_1]\\oplus T_2[x_0 || x_1][/$]
        -
                uuid: 50650fe5-887f-4b2c-a138-d651bcdb725d
                front: Konstrukce [$]k[/$]-univerzálního hashování
                back: >
                        [$]p\\in P, x\\in \\Z_p,
                        a_0,\\ldots a_{k-1}\\in \\Z_p náhodně<br>
                        <br>
                        [$$]h_{a_0,\\ldots a_{k-1}}(x)=\\sum_{i=0}^{k-1} a_i x^i \\bmod p[/$$]
                        <br>
                        Je [$]k[/$]-univerzální.
        -
                uuid: c2b4ae9f-c490-459c-84e9-314ca20ad298
                front: K čemu jsou užitečná Mersennova prvočísla?
                back: >
                        Dá se jimi rychle modulit: [$]y=(y \\& p) + (y \\gg a)(\\bmod p)[/$]
        -
                uuid: ee03f9d3-2e24-4b87-b30d-e1db4c34f915
                front: Perfektní hashování
                back: >
                        Vezmu 2-univerzální hashovací systém.
                        [$]P_{h\\in H}[h(x_1)=h(x_2)]=1/m[/$].
                        <br><br>
                        Očekávaný počet rolí, co kolidují: [$]\\leq n^2\\cdot\\frac{1}{m}[/$]
                        <br><br>
                        Když [$]m\\geq 2n^2[/$], pak [$]P[h\\ \\text{je perfektní pro}\\ S]\\geq\\frac{1}{2}[/$].

