deck: Magisterské státnice::Řešení úloh a plánování
notes:
        # AI lecture03eng
        -
                uuid: 8342b4dc-4a9c-4c8c-b57f-94b53653afed
                front: Prohledávání stavového prostoru jako stromu -- velmi obecně
                back: >
                        Začni v rootu. Zkontroluj jestli jsem v goalu.
                        Expanduj cíl, pomocí prohledávací strategie vyber další stav.
        -
                uuid: e6ef86bf-1eba-4bb5-99c8-9760d4ad3ec9
                front: Co obsahuje vrchol v prohledávacím stromu ve stavovém prostoru?
                back: >
                        Současný stav, pointer do předka, akci která vedla, cenu od kořene, hloubku
        -
                uuid: fe251941-8358-4b01-b741-0a8f376d9473
                front: Prohledávání stavového prostoru - Fringe
                back: >
                        Ještě neexpandované vrcholy
        -
                uuid: be2091b5-6825-446d-80c1-4b77bc72c965
                front: Co nás zajímá na algoritmech na prohledání stavového prostoru?
                back: >
                        Kompletnost - najde řešení když existuje?<br>
                        Najde optimální řešení?<br>
                        Časová složistost<br>
                        Prostorová složitost
        -
                uuid: 6a6ebfa1-3d51-40c4-8c5c-9f93993d4845
                front: Jaké faktory určují složitost prohledávání stavového prostoru?
                back: >
                        Branching faktor: [$]b[/$]<br>
                        Depth: [$]d[/$] (do nejbližšího goalu)<br>
                        Path length: [$]m[/$] (maximální délka cesty)
        -
                uuid: c79e7482-5e74-47bd-a372-fb3772d4d8b6
                front: Informované a neinformované hledání
                back: >
                        Informované hledání: používám heuristiky
        -
                uuid: 3a7a6840-ec4b-448f-98d4-1394cbc76b37
                front: Prohledávání stavového prostoru - BFS, časová složitost, prostorová složitost, optimalita
                back: >
                        Expanduj všechno v dané hloubce -- FIFO.
                        Je kompletní.<br>

                        Optimalita: Nejmělčí cílový stav není nutně optimální!<br>

                        Časová složitost: [$]\\O(b^{d+1})[/$], to samé prostor. Brzo dojde.
        -
                uuid: 0b4190bb-97c2-45be-b979-8a27aa7278f9
                front: Uniform-cost search, kompletnost, optimalita, složitost
                back: >
                        Modifikuju BFS abych našel optimální řešení.
                        Expanduju node, který má nejmenší cost [$]g(n)[/$].
                        (Bacha na zero-cost steps!)<br>

                        Completeness and optimality: jestli cena kroku je kladná (nenulová)<br>

                        Složitost záleží na ceně optimální cesty.
                        [$]\\O(b^{1+\\lfloor C^*/\\varepsilon \\rfloor})[/$]<br>

                        Může to být mnohem horší než BFS.
        -
                uuid: 6f7b2909-b6c3-4bf9-9a5e-e74daaee48b1
                front: Prohledávání stavového prostoru - DFS, složitost - prostorová, časová
                back: >
                        Vždy expanduj nejhlubší node, pomocí LIFO jako frontieru.
                        Není kompletní (může se zacyklit), nemusí najít optimum.<br>

                        Složitost: [$]\\O(b^m)[/$], kde [$]m[/$] je maximální hloubka. (Délka cesty může být [$]d<<m[/$]...)<br>

                        Prostorová složitost: [$]\\O(bm)[/$]<br>
        -
                uuid: 66403ffa-1ab6-4d9e-a8c6-0d54fa2050f2
                front: Jaké vychytávky umí zlepšit paměťovou složitost DFS?
                back: >
                        Jestli dělám backtracking a generuju jenom jednoho successora: [$]\\O(m)[/$].
                        Modifikuj jenom tenhle stav: [$]\\O(m)[/$] akcí, [$]\\O(1)[/$] stavů
        -
                uuid: 0fa8e941-36e3-4319-af1f-63cb7479629f
                front: Jak můžu určit depth limit pro DFS?
                back: Můžu to vykoukat z problému (například, počet měst, průměr grafu). Čím větší hloubku dovolím DFS, tím déle bude trvat.
        -
                uuid: fd7c9d1d-65c5-4b74-95f3-f141681c5bd0
                front: Jak udělat z depth-limited search kompletní algoritmus?
                back: Iterative deepening
        -
                uuid: 9ea6deed-73cd-4de5-85ba-ba861f8557d9
                front: Iterative deepening - kompletnost, optimalita, spotřeba paměti, časová složitost
                back: >
                        Kompletnost: ano, když je konečný branching faktor<br>
                        Optimalita: jenom jestli je cena cesty úměrná hloubce<br>
                        Paměť: [$]\\O(bd)[/$]<br>
                        Časová složitost: [$]\\O(b^d)[/$] (BFS prozkoumá totiž ještě jeden level?)
        -
                uuid: eed965d2-4aa4-4a40-ad8b-86deaf7d65d0
                front: Jakou metodu uninformed search použít když je velký stavový prostor a neznám hloubku řešení?
                back: Iterative deepening
        -
                uuid: ed0b5358-68fd-4cdb-b0a8-12a8af3a5829
                front: Bidirectional search
                back: >
                        Dva searche zároveň: forward a backward.
                        [$]b^{d/2}+b^{d/2}<<b^d[/$].
                        <br>
                        Než expanduju node, prověřím že není ve druhém frontieru.
                        Jeden musím nechat v paměti (tedy [$]\\O(b^{d/2})[/$] na paměť).
                        Jestli použiju BFS, dostanu kompletní algoritmus.
                        (Ale první řešení pořád nemusí být optimální.)
        -
                uuid: 6283bbe8-7558-41d5-9469-ccd7dacf5476
                front: Problém při zpětném prohledávání ve stavovém prostoru
                back: >
                        Když cíl je nějaká abstraktní funkce (např. 8-queens).
        # AI lecture04eng
        -
                uuid: a3c06aab-9f5b-4e12-ae4b-70c719757186
                front: Algoritmy informovaného prohledávání
                back: B(est)FS, A*, IDA*, RBFS, SMA*
                markdown: false
        -
                uuid: 7b16ee4b-f787-4dac-b73b-cc27f933e29f
                front: Jak budovat heuristiky pro informované prohledávání?
                back: Relaxace problému, pattern databases
        -
                uuid: e119c8fb-e53c-4804-bcb5-38792d3607f4
                front: Funkce heuristické funkce
                back: >
                        Odhaduje délku nejkratší/nejlevnější cesty do cílového stavu.
                        Když [$]h(n)=0[/$], tak je to cíl.
        -
                uuid: 48d49a75-1ab7-4a3f-9bfd-c62372add5da
                front: (Greedy) best-first search, optimalita?
                back: >
                        Jako první expanduj node, který má nejmenší vzdálenost do cíle.<br>

                        Nemusí najít optimální cestu.
        -
                uuid: 1ce201f6-2289-41a2-8808-c7d39101043c
                front: Zkonstruuj příklad, kdy greedy best-first-search nenajde optimální cestu.
                markdown: false
                back: >
                        <pre>
                             ___(100)___O____(10)___GOAL
                            /
                           O
                            \___(20)____O____(20)___GOAL
                        </pre>
        -
                uuid: 75011b95-88e2-4166-a504-ac5cf5cc9fa2
                front: Časová a paměťová složitost greedy best-first-search
                back: >
                        [$$]\\O(b^m), \\O(b^m)[/$$]
        -
                uuid: 1cf39109-4c9c-49bc-9ba2-4d64cdbbeba6
                front: Kompletnost greedy best-first-search
                back: >
                        Může se zacyklit. Musíme dělat prevenci cyklů.
        -
                uuid: 47a37ccc-2a54-4345-b09a-ef2057be9040
                markdown: false
                topic: A*
                front: Podle čeho prioritizuje A*?
                back: >
                        Podle [$]f(n)=g(n)+h(n)[/$], kde [$]g(n)[/$] je délka cesty do [$]n[/$] z kořene
        -
                uuid: c4f970b6-0348-48a8-8fc3-961866eb81c6
                topic: A*
                front: Jaká heuristika je admisibilní? Co to znamená pro [$]f(n)[/$]?
                back: >
                        [$$]h(n)\\leq\\text{cena nejlevnější cesty z}\\ n\\ \\text{do cíle}[/$$]
                        Tedy optimistický pohled, [$]f(n)[/$] je pak dolní odhad na délku cesty do cíle skrz [$]n[/$].
        -
                uuid: fe78b7a8-0b18-43ad-a775-3957c9e60bca
                topic: A*
                front: Jaká heuristika je monotónní/konzistentní?
                back: >
                        Ať je [$]n'[/$] následník [$]n[/$] skrz akci [$]a[/$].
                        Pak:
                        [$$]
                        h(n)\\leq c(n,a,n') + h(n')
                        [/$$]
                        Je to forma trojúhelníkové nerovnosti.
        -
                uuid: 169cbbbe-f02f-4105-b9db-cd4a6301f30b
                topic: A*
                front: Vztah přípustných(admisibilních) a monotónních heuristik
                back: >
                        Monotónní heuristiky jsou admisibilní.<br>

                        Ať je [$]n_1,n_2,\\ldots n_k[/$] optimální cesta z
                        [$]n_1[/$] do cíle [$]n_k[/$].<br>
                        Pak z monotonie: [$]h(n_i)-h(n_{i+1})\\leq c(n_i,a_i,n_{i+1})[/$].<br>
                        Před teleskop: [$]h(n_1)\\leq\\sum_{i=1}^{k-1} c(n_i,a_i,n_{i+1})[/$]
        -
                uuid: 4415b7e7-88da-4811-b3d3-7d76a308e43f
                topic: A*
                front: Monotónní heuristiky a hodnoty [$]f(n)[/$].
                back: >
                        Pro monotónní heuristiku hodnoty [$]f(n)[/$] na žádné cestě neklesají.<br>

                        Ať je [$]n'[/$] successor [$]n[/$], tedy [$]g(n')=g(n)+c(n,a,n')[/$].<br>

                        Pak: [$]f(n')=g(n')+h(n')=g(n)+c(n,a,n')+h(n')\\geq g(n)+h(n)=f(n)[/$]
        -
                uuid: 7bf554b8-2b8d-4310-8302-a8d634a8c265
                topic: A*
                front: Jaké dva grafové meta-algoritmy se liší a jak? Co heuristiky?
                back: >
                        Tree-Search: stačí mít admisibilní heuristiku aby byl A-star optimální.<br>
                        Graph-Search: musí být monotónní.<br>

                        V Graph-Search jde jednoho vrcholu dosáhnout více cestami, kde druhá může zkrátit první.
        -
                uuid: 44799b49-ffd1-4c2c-90ef-942bb2b43b82
                topic: A*
                front: Kdy je A-star optimální v Tree-Search? Důkaz.
                back: >
                        Když je [$]h(n)[/$] admisibilní heuristika.<br>

                        Ať je [$]G_2[/$] cíl, který je na fringe a [$]C^{ * }[/$] je optimální cost.<br>
                        Pak: [$]f(G_2)=\\underbrace{g(G_2)+h(G_2)=g(G_2)}_{h(G_2)=0}>C{ * }[/$]<br>

                        Ať [$]n[/$] je node na fringe co leží na optimální cestě.
                        Pak: [$]f(n)=g(n)+h(n)\\leq C^{ * }[/$], protože [$]h[/$] je admisibilní.<br>

                        Dohromady: [$]f(n)\\leq C^{ * }>f(G_2)[/$]. Proto algoritmus nejdřív rozbalí [$]n[/$].
        -
                uuid: 3f87c2c1-0080-4ac1-9588-bf2b840124e4
                topic: A*
                front: Kdy je A-star optimální v Graph-Search? Důkaz. Jak se to dá řešit jinak?
                back: >
                        Když je heuristika monotónní.<br>

                        Můžu taky (zřejmě) vybrat z obou cest co vedou do uzavírané cesty tu lepší, ale to chce extra bookkeeping.<br>

                        Protože hodnoty [$]f(n)[/$] na žádné cestě neklesají
                        a expanduju vrchol co má [$]f(n)[/$] nejmenší,
                        tak mezi "otevřenými" cestami do [$]n[/$] nemůže existovat
                        žádná kratší než ta, co už znám.
                        Proto první uzavřený goal node je optimální.
        -
                uuid: d916f074-cb0c-4bc5-b805-13959d9ae4b5
                topic: A*
                front: >
                        A-star a kontury a cesta do cíle.
                        Co jsou nody, které algoritmus za svůj běh expanduje?
                back: >
                        Pro neklesající [$]f(n)[/$] jdou nakreslit podle hodnot [$]f(n)[/$].
                        Čím mám přesnější [$]h(n)[/$], tím jsou užší kolem cesty do cíle<br>

                        Nody na kontuře co mají [$]f(n)<C^{ * }[/$] se expandují, některé nody
                        s [$]f(n)=C^{ * }[/$] se můžou expandovat, [$]f(n)>C^{ * }[/$] se neexpandují.<br>

                        A-star je optimálně efektivní pro libovolnou konzistentní heuristiku.
        -
                uuid: c3d6269c-f870-4d63-a63d-0e62d52953eb
                topic: A*
                front: Časová složitost a nejvyšší počet expandovaných nodů
                back: >
                        Až exponenciální
        -
                uuid: aad7eae5-bf63-421b-831c-0ef427453977
                topic: A*
                front: Jak můžu zabezpečit aby se neexpandoval exponenciální počet nodů?
                back: >
                        Když [$]|h(n)-h^{ * }(n)|\\leq \\O(\\log h^{ * }(n))[/$],
                        kde [$]h^{ * }[/$] je délka optimální cesty.
        -
                uuid: f3d32243-faa9-4ac7-8264-91c8391a6f7b
                topic: A*
                front: Paměťová složitost
                back: >
                        Držím v paměti všechny expandované nody, je jich až exponenciálně.
        -
                uuid: baefb97c-b818-4b65-8c69-6eef61c6293f
                topic: A*
                front: Co je bottleneck?
                back: >
                        Paměť. Spotřebuje se jí stejně jako času a obvykle dojde první.
        -
                uuid: 2989ad27-c59d-4cdb-98a2-7cafed518160
                front: IDA* -- algoritmus
                back: >
                        Iterative deepening A-star.<br>

                        Začnu s malým limitem na [$]f(n)[/$] (konkrétně
                        [$]f(\\text{kořen})[/$]. Pomocí DFS prohledám všechny
                        vrcholy, co mají nejvýše takové [$]f(n)[/$].<br>

                        Když nenaleznu řešení, tak zvýším limit a opakuju.
        -
                uuid: 5bac3bf9-057e-412e-82c4-289a1f4c484f
                topic: IDA*
                front: Výhoda oproti A-star
                back: >
                        Má menší spotřebu paměti, protože je depth-first.
        -
                uuid: 7276de86-7996-4f66-b737-23afb9bd6259
                front: Recursive best-first search -- algoritmus
                back: >
                        V každém volání si pamatuju odhady na délky optimálních
                        cest skrz successory.<br>

                        Odhady začnu jako [$]f(n')[/$].<br>

                        Rekurzivně se zavolám v successorovi, co má nejmenší
                        odhad.<br>

                        Jakmile zjistím, že exploruju, ale někde v mém předkovi
                        je slibnější podstrom, abortuju a jdu nahoru.
                        Po cestě nahoru probublám přesnější (vyšší)
                        odhad na délku cesty skrz současný podstrom.
        -
                uuid: 0776ba77-2a66-4efb-8524-d3de22131639
                front: Kdy je IDA-star optimální?
                back: >
                        Když používá admisibilní heuristiku.
        -
                uuid: b69ec95e-fb52-4868-8c51-1437d5509218
                front: Recursive best-first search -- spotřeba paměti
                back: >
                        [$$]\\O(bd)[/$$]
        -
                uuid: b2f46ed6-cbb5-428c-a811-44b90e9d1d36
                front: Recursive best-first search -- spotřeba času
                back: >
                        Exponenciální (excesivní regenerace)
        -
                uuid: 21870f9e-b509-4de0-9894-065b9829acb3
                front: SMA* -- algoritmus
                back: >
                        Simplified memory-bounded A-star.<br>

                        Pro každý vrchol si pamatuju náš současný nejpřesnější odhad na délku
                        cesty skrz něj, jako v IDA-star.<br>

                        Jako v A-staru expanduju node s nejmenším odhadem na délku
                        cesty do cíle skrz něj.<br>

                        Když mi dojde paměť, smažu nejhorší list; jestli jich je několik,
                        smaž z nich ten nejmíň hluboký. Jeho informace pošli nahoru.
        -
                uuid: b094b561-0314-4e8b-a841-b67e6bffb178
                front: SMA* -- optimalita
                back: >
                        Když je dost paměti na zapamatování si nejlepší cesty (a heuristika je admisibilní), SMA-star najde v tree-search nejlepší cestu.<br>
                        Jestli není dost paměti, najde tu nejlepší co se do paměti vejde.
        -
                uuid: e65df462-b1d2-4ef4-b451-8aa670451f94
                front: Příklady heuristik získaných relaxací 8-puzzle
                back: >
                        Počet špatně umístěných tilů.<br>

                        Součet vzdáleností tilů od jejich cílů (Manhattan heuristika).
        -
                uuid: ab93dba1-29b3-44a0-82b3-d9d888223810
                front: Jak se poměřují dobrosti A-star heuristik číselně?
                back: >
                        Ať heuristika rozbalí [$]N[/$] nodů.
                        Porovnáváme [$]b^{ * }[/$], branching faktor
                        plného stromu co má [$]N+1[/$] nodů ([$]N+1=1+b^{ * }+\\ldots+(b^{ * })^d[/$]).
        -
                uuid: b7042e65-c900-4aa5-9d5f-f16326927b72
                front: Definice - dominující heuristika
                back: >
                        Heuristika [$]h_2[/$] dominuje heuristiku [$]h_1[/$],
                        když [$] (\a n) h_2(n)\\geq h_1(n)[/$].
        -
                uuid: 2efbf879-7dbb-4cb1-a6d1-643ee9b82937
                front: Jak se liší A-star na dvojici heuristik, kde jedna dominuje druhou?
                back: >
                        A-star na dominující heuristice expanduje nejvýše tolik nodů jako na dominované.
                        Expanduje totiž nody, kde [$]f(n)<C^{ * }[/$], neboli [$]h(n)<C^{ * }-g(n)[/$].
                        Když tedy expanduje node pomocí dominující heuristiky, expanduje ho i při dominované heuristice.
        -
                uuid: 32c66cbc-4dec-40b6-9b0c-da669133e8c9
                front: Kdy je lepší dávat dominující heuristiku?
                back: >
                        Vždy, když zůstane admisibilní a když netrvá moc dlouho ji počítat.
        -
                uuid: 540f40fe-43b4-4f0c-8020-efd283bd5117
                front: Jak můžu zkombinovat různé heuristiky co se navzájem nedominují?
                back: >
                        Můžu z nich vzít maximum, které je všechny dominuje.
        -
                uuid: 0ad36a46-3dd1-4d40-93bb-bd4a24b0e34d
                front: Jak můžu stavět heuristiky kromě relaxace? Jak se to implementuje? Na co dát bacha?
                back: >
                        Pattern database.<br>

                        Například pro 8-puzzle: podívám se jenom kde je 1,2,3,4,
                        všechny ostatní přeznačím jako "?". Vyřeším problém
                        dostat na svoje místo 1,2,3,4.<br>

                        Heuristika: maximový čas na vyřešení všech patternů
                        co matchují současný stav.<br>

                        Bacha: součet cen patternů nemusí být admisibilní (řešení jednoho
                        patternu může pomoct k řešení druhého).
        # ai2 lecture05eng
        -
                uuid: 8350e13e-3fc2-4d61-af47-3c5970ec635c
                front: Algoritmy pro lokální vyhledávání
                back: >
                        Hill climbing, simulated annealing, local beam search, generické algoritmy
        -
                uuid: 744461b9-f721-4f1b-9578-cbd991934665
                front: Problémy hill climbingu
                back: >
                        Lokální optimum: všichni sousedi jsou horší, nejde utéct.<br>

                        Ridge -- sekvence lokálních optim<br>

                        Plató -- může se zacyklit
        -
                uuid: cf2b97e4-16a5-44db-aabc-f8629b04b4ba
                front: Varianty hill-climbingu
                back: >
                        Stochastický: vyber si náhodně mezi zlepšujícími kroky;
                        pravděpodobnost může záležet na velikosti zlepšení.
                        <br>
                        First-choice: jdi do prvního lepšího successora
                        co najdeš.
                        <br>
                        Random-restart: dělej náhodné hill-climbingy z náhodných stavů.
                        Když má hill climbing šanci [$]p[/$] na úspěch,
                        očekávaný počet restartů je [$]1/p[/$].
                        <br>
                        (Velmi dobré na N-queens.)
        -
                uuid: 9569e3b1-061e-42b1-8669-0f2cf4752bf1
                front: Simulované žíhání
                back: >
                        Snižuje teplotu.

                        Stav se přijme, když je to zlepšení, nebo když mu to
                        dovolí cooling schema ([$]p\\sim \\exp(\\Delta E/T)[/$]).
        -
                uuid: 5ff7f53f-a6d2-4e13-82a8-31d3ca4c2412
                front: Local beam search; algoritmus, jak se dá zvětšit diverzita?
                back: >
                        Držím si [$]k[/$] stavů místo jednoho.
                        V jednom kroku vygeneruju všechny jejich successory
                        a vyberu z nich do dalšího kroku [$]k[/$] nejlepších.<br>

                        Diverzita se dá zlepšit stochastikou - vyber s pravděpodobností
                        úměrnou tomu, jak jsou dobré.
        -
                uuid: f505034a-5d26-4974-b7be-827333cd326d
                front: Online vs. offline search
                back: V online vyhledání prolínám pohyb a vyhledávání -- prostředí je dynamické. Hodí se taky pro nedeterministické, neznámé prostředí.
        -
                uuid: 85031dd6-cfcd-4704-b6b3-8bd414ae7494
                front: Co umí agenti v on-line search?
                back: >
                        V cíli znají dovolené akce, znají cost akcí když znají cíl
                        ze kterého se jde, umí identifikovat cílový stav.<br>
                        Umí si budovat mapu (poznat kde byl).
                        Akce jsou deterministické.
                        Agent má admisibilní heuristiku.
        -
                uuid: 1b52e972-a1cf-4c26-95ea-c98c40760087
                front: Jak se porovnávají online vyhledávací algoritmy? Jak nejhůř to může dopadnout?
                back: >
                        Podle poměru kvality proti offline vyhledávání.<br>

                        Adversary argument: prostředí může být smrtelné.
                        Předpokládáme, že ze všech stavů se dá dosáhnout cíle.<br>

                        Protože můžu arbitrárně prodloužit libovolnou cestu (adversary argument),
                        porovnáváme úspěšnost online search vzhledem k velikosti celého stavového prostoru -- ne vzhledem k hloubce nejnižšího cíle.
        -
                uuid: f2f0aca9-d7da-4063-975d-95ba7925b73e
                front: Online DFS
                back: >
                        Pro každý stav si pamatuj ještě nevyzkoušené akce<br>

                        Pamatuj si pro každý stav, jaké backtracky jsme v něm ještě nezkusili.
                        (NOTE: v jedné cestě do něj můžeme vstoupit různými způsoby.)<br>

                        Funguje jenom když jsou všechny akce reverzivilní.
                        Kompetitivní poměr může být libovolně špatný.
                        Přinejhorším projde každou hranu dvakrát.
        -
                uuid: 9ac90ede-b46a-40ac-83d3-9f276c799e49
                front: Lokální online vyhledávání
                back: Kombinace HC a náhodné procházky. Nakonec najde cíl nebo dokončí exploraci (v konečném stavovém prostoru), ale může to být hodně dlouhé (např., exponenciální -- žebřík).
        -
                uuid: 5f8be220-b3d0-4070-a47c-a3da07f0829f
                front: Jak můžu při online vyhledávání použít paměť?
                back: >
                        Můžu si pro stavy pamatovat nejlepší odhady na délku
                        cesty z nich do cíle. Začnu s heuristikou, ale můžu
                        to zpřesňovat při návratech.
        -
                uuid: 64893b54-cf13-4f19-8ff3-97f4c15ae5b0
                front: LRTA* algoritmus
                back: >
                        Dělá lokální kroky a učí se důsledy akcí a lepší odhad délky do cíle (H).<br>

                        Mezi akcemi vyber tu, co minimalizuje LRTA-cost, která je založená
                        i na podpoře explorace. (Když nevíme, co akce dělá, předpokládáme,
                        že vede hned do cíle -- [$]h(s)[/$].)
        # DPV 01
        -
                uuid: 8e2b26e8-30f3-4c2c-aba3-6c85c6284774
                topic: Řešení SAT
                front: NNF formule a jak rychlý je převod
                back: >
                        Formule co má jenom [$]\\wedge, \\vee, \\neg[/$] a negace je jenom u literálů.
                        Převod trvá lineární čas (de Morgan a eliminace dvojité negace formuli neprodlužují).
        -
                uuid: 0f9b799d-839b-4e9e-8ae1-2314bae8f593
                topic: Řešení SAT
                front: Převod do CNF v lineárním čase
                back: >
                        Tseitinovo kódování.<br>
                        Vyrobím si pro formuli generující strom.<br>
                        Pro vnitřní vrcholy stromu si vyrobím nové proměnné.
        -
                uuid: dd575466-88ed-4d73-8c3b-a3166cc6bcc0
                topic: Řešení SAT
                front: Definice - Antecedentní klauzule (v SAT solveru)
                back: >
                        Klauzule, která vyvolala unit propagaci literálu (ve které se nacházel).
        -
                uuid: ad4dd92e-6a3a-4d07-80d9-4e797a51ccfe
                topic: Řešení SAT
                front: Definice implikačního grafu
                back: >
                        Graf popisuje fázi DPLL.<br>
                        Vrcholy jsou proměnné a K.
                        Jsou označené ohodnocením a "decision levelem".
                        <br>
                        Hrany jsou důvody k přiřazení hodnoty proměnné.
                        Hrana mezi [$]x\\rightarrow y[/$]:
                        [$]Antecedent(y)[/$] obsahuje buď [$]\\neg x[/$] a
                        [$]\\alpha(x)=1[/$], nebo obsahuje [$]x[/$] a [$]\\alpha(x)=0[/$].
                        Hrana je označena [$]Antecedent(y)[/$].
                        <br>
                        Vertex K označuje konflikt:
                        vlož hranu [$]x\\rightarrow K[/$]
                        pokud existuje konfliktní klauzule [$]c[/$] vzhledem k [$]\\alpha[/$]
                        a [$]c[/$] buď obsahuje [$]\\neg x[/$] a [$]\\alpha(x)=1[/$],
                        nebo obsahuje [$]x[/$] a [$]\\alpha(x)=0[/$].
                        Tuto hranu označ konfliktní klauzulí.
        -
                uuid: d819b91f-b306-437a-9aed-189891951eb5
                topic: Řešení SAT
                front: Jak se z implikačního grafu vykouká nová konfliktní klauzule?
                back: >
                        Řez v grafu mezi rozhodnutími a K.
        -
                uuid: 8b253b81-ab75-44b3-8dfd-6454c64fcde2
                topic: Řešení SAT
                front: K čemu jsou v implikačním grafu řezy?
                back: >
                        Řez v grafu mezi rozhodnutími a K je konfliktní
                        klauzule implikovaná rozhodnutími.
        -
                uuid: f2529af7-25ca-42a2-a230-ec5edf03cb03
                topic: Řešení SAT
                front: Algoritmus CDCL - za co je to zkratka, co dělá?
                back: >
                        Conflict-driven clause learning.<br>

                        Udělej unit propagaci a pure variable elimination.<br>

                        Opakuj:
                        <ul>
                        <li>Vyber proměnnou, která ještě není ohodnocená, nebo skonči.
                        <li>Přidej nové ohodnocení do modelu.
                        <li>(@) Udělej unit propagaci
                        <li>Jestli unit propagace dopadla špatně,
                        <li>zanalyzuj konflikt -- najdi backtrack úroveň a vlož novou naučenou konfliktní klauzuli,
                        <li>backtrackuj před konflikt (smaž pozdější přiřazení),
                        <li>jdi na (@)
                        </ul>
        -
                uuid: 1c2792bd-77f2-46b9-bc3c-34fad1a2a7a4
                topic: Řešení SAT
                front: Jak v CDCL vybrat vhodnou klauzuli k naučení?
                back: >
                        Asserting clause: konfliktní klauzule co obsahuje
                        přesně jeden literál ze současného rozhodnutí.
                        (Po backtracku unit propagace okamžitě dá rozhodnutí.)
                        <br>
                        Unique implication point: takový bod, skrz který vedou
                        všechny cesty z posledního decision vertexu do K.
                        <br>
                        Vybereme UIP, který je nejbližší k K.
                        Naučíme se jako konfliktní klauzuli tenhle UIP spolu
                        s opakem literálu z poslední rozhodovací vrstvy.
        -
                uuid: 597265d0-ed3d-4af5-ad9f-dfc558da09d0
                topic: Řešení SAT
                front: Kam v CDCL backtrackovat?
                back: >
                        Podívej se na klauzuli, kterou ses naučil.
                        Backtrackni do druhé nejhlubší úrovně přiřazení v ní.
                        (Smaž všechny rozhodnutí udělané potom.)
        -
                uuid: b72a9764-ad55-4a3b-b72a-4376e36eed3c
                topic: Řešení SAT
                front: CDCL - detaily analýzy konfliktu
                back: >
                        Vezmi konfliktní klauzuli.

                        Dokud neobsahuje konfliktní klauzule právě jeden literál
                        z posledního decision levelu: vezmi poslední v ní
                        dosazený literál a resolvuj ho s jeho antecedentem.
        -
                uuid: cea23069-42ba-472c-b0f0-f875e55b8cf7
                topic: Řešení SAT
                front: Heuristiky pro výběr proměnných k dosazení
                back: >
                        VSIDS (Variable State Independent Decaying Sum),
                        Berkmin
        -
                uuid: 05bb9ed3-3b6f-44fa-a69d-519a55ef075c
                topic: Řešení SAT
                front: Heuristika VSIDS
                back: >
                        Každý literál má skóre. Když se naučím klauzuli,
                        přičtu jejím literálům 1, pravidělně všechny skóre
                        exponenciálně zmenšuju.
                        Preferuju řešit konfliktní klauzule.
        -
                uuid: 3bfa2a31-4515-4bd9-abcf-fa2ce8ef91f9
                topic: Řešení SAT
                front: Heuristika Berkmin
                back: >
                        Každá proměnná, literál má VSIDS skóre, které se nedělí
                        průběžně.<br>
                        Konfliktní klauzule házím do stacku.
                        Když vybírám proměnnou, vezmu jednu klauzuli
                        ze stacku, z ní dosadím do proměnné s nejvyšším skóre
                        a polaritu podle skóre literálu. Jestli je stack
                        vyberu jinak.
        -
                uuid: 5f932d37-3de7-43c5-8c67-50e2e844762d
                topic: Řešení SAT
                front: Sledování dvou literálů
                back: >
                        V každé nevyřešené klauzuli si označím dva nedosazené literály.
                        <br>
                        Pro každou proměnnou si pamatuju označené výskyty.
                        Když dosadím třeba [$]x_1=0[/$], zkontroluju jenom
                        klauzule co sledují [$]x_1[/$] -- potřebuju v nich
                        najít další proměnnou ke sledování. Jestli neexistuje,
                        tak z klauzule zbyla jednotková klauzule.
        -
                uuid: 75e77a4d-deea-4807-86d3-fbeede06e813
                front: Co udělá sledování dvou literálů při backtracku?
                back: Nic se nemusí měnit
        # AI1 lecture06eng (CSP)
        -
                uuid: 088f9f53-2262-4422-9b13-b5cfe69f4538
                topic: CSP
                front: >
                        Základní termíny
                back: >
                        Domény, proměnné, podmínky (různé arity), (filtrování).
        -
                uuid: 1136669b-f0ad-4b35-80ec-ff85de0e11f1
                topic: CSP
                front: >
                        Podle jakých heuristik budeme vybírat proměnnou k dosazení?
                back: >
                        Tu, jejíž dosazení do nejdříve selže (fail-first).
                        Tedy:<br>

                        dom heuristika: proměnná s nejmenší doménou<br>

                        deg heuristika: proměnná co má nejvíc podmínek<br>

                        dom+deg heuristika: mezi proměnnými s nejmenší doménou
                        vyber tu co má nejvíc podmínek
        -
                uuid: 97caa973-7b9c-4385-9a39-c21d00f284a7
                topic: CSP
                front: >
                        Podle jakých heuristik budeme vybírat pořadí hodnot k dosazení?
                back: >
                        Succeed-first: Tedy:<br>

                        Taková proměnná co nejméně omezí ostatní proměnné.<br>

                        Zkus problém zrelaxovat, najít řešení relaxovaného problému
                        a z něj vzít hodnotu.<br>

                        Problem-dependent heuristics.
        -
                uuid: 335f20af-07e8-405a-8331-f23057d628df
                topic: CSP
                front: Forward checking
                back: >
                        Po přiřazení zkontroluj constrainy mezi právě přiřazenou
                        proměnnou a budoucími proměnnými.
        -
                uuid: 0ab920fd-72d2-44e7-8c34-e1fc95d662eb
                topic: CSP
                front: Arc consistency
                back: >
                        Každá hrana má podporu, tedy každá hodnota v každé doméně
                        má podporu na druhé straně podmínek.
                        Při každé změně uděláme další filtrování.
        -
                uuid: 9dd1edf2-6c4f-41f7-a611-a4a54845be01
                topic: CSP
                front: AC-3 algoritmus a časová složitost
                back: >
                        Měj queue všech hran.
                        Vyber hranu z queue.<br>

                        Pro hranu zkontroluj, že každé dosazení doleva má podporu vpravo.
                        (Kontrola trvá [$]d^2[/$].)<br>

                        Pokud jsem něco odebral, přidám všechny hrany
                        ze změněné domény do queue.<br>

                        Tedy celkem složitost: [$]\\O(ed^3)[/$], kde [$]e[/$] je
                        počet podmínek.
        -
                uuid: e8cbd3a0-6013-4c57-9279-d6ae60d6f8c7
                topic: CSP
                front: >
                        [$]k[/$]-konzistence - definice
                back: >
                        Když pro každé konzistentní přiřazení [$](k-1)[/$]
                        proměnných ho umíme rozšířit o další proměnnou
        -
                uuid: ee762038-22a3-4ef8-b129-786aa4bbc750
                topic: CSP
                front: >
                        [$]k[/$]-konzistence a řešení bez backtracků
                back: >
                        Jestli je problém [$]k[/$]-konzistentní pro [$]k\\in\\{1,\\ldots n\\}[/$],
                        jde vyřešit bez backtracků.
        -
                uuid: caa2d40c-363e-4b69-8ecd-5cf307824bdf
                topic: CSP
                front: Časová složitost [$]k[/$]-konzistence
                back: >
                        Exponenciální v [$]k[/$]
        -
                uuid: 6f35387f-61d2-4b92-afbc-65eb98efc6f4
                topic: CSP
                front: Globální podmínky a příklad
                back: >
                        Obalují podproblém - například <code>all_different</code>
                        obaluje párování v bipartitním grafu
        -
                uuid: 41c999c5-02dd-4903-9fae-97bbdbd1ee53
                topic: CSP
                front: Jak se v CSP řeší optimalizace?
                back: Branch and bound
        # planovani lecture01
        -
                uuid: c2d9d34f-5d36-4601-b17a-5cbec59f321d
                front: Plánování vs. rozvrhování
                back: >
                        Plánování: počáteční a požadovaný stav světa,
                        popis akcí, výstup je plán. Nezajímá nás čas ani zdroje.
                        Téma umělé inteligence, složitost často horší než NP-c.
                        <br>
                        Rozvrhování: máme částečně uspořádané aktivity
                        a dostupné zdroje, výstup je alokace. Čas a zdroje
                        jsou omezené, aktivity jsou známé předem.
                        Téma operačního výzkumu, typicky NP-c.
        -
                uuid: 763130f5-f272-4555-9a37-207bd980c1ad
                front: Značení - počáteční stav, cílová podmínka, operátory měnící stav
                back: >
                        [$$](s_0,g,O)[/$$]
        # P&R lecture02
        -
                uuid: 95b3a90e-dbc5-4bab-8713-1468756d7622
                front: Konceptuální model plánování, cíle; zjednodušení světa?
                back: >
                        Stavy: množina, akce: množina, události mimo naši kontrolu,
                        přechodová funkce<br>
                        Cíle: cílový stav / splnění dané podmínky v plánu (např.
                        "vyhni se tomuhle stavu" / optimalizace objektivní funkce<br>

                        Systém je konečný, plně pozorovatelný, deterministický,
                        statický (žádné události), cíle jsou jenom dosažení
                        nějakého stavu, plány jsou sekvenšní, čas je implicitní
                        (akce jsou okamžité), plánujeme offline
        -
                uuid: 732febcc-69de-4eac-ae60-dcff6f9ec4e2
                topic: STRIPS plánování
                front: >
                        Stav systému, akce, plánovací doména,
                        použitelnost akce, přechodová funkce
                back: >
                        Stav: množina platných výroků,
                        akce je přidá nebo smaže<br>
                        Doména nad výroky [$]L[/$]: [$]\\Sigma=(s,A,\\gamma)[/$],
                        kde [$]s\\subseteq \\P(L)[/$] je stav.
                        <br>
                        Akce: [$]a=(precond(a),eff^{-}(a), eff^{+}(a))[/$];
                        ([$]eff^- \\cap eff^+ = \\emptyset[/$]),
                        použitelná když [$]precond(a)\\subseteq s[/$]
                        <br>
                        Přechodová funkce: [$]\\gamma(s,a)=(s-eff^{-}(a))\\cup eff^+(a)[/$]
                        je-li [$]a[/$] použitelná akce.
        -
                uuid: 0b79d1b3-d1c5-403f-ab8b-49b95b4cc411
                topic: STRIPS plánování
                front: Definice - Plánovací problém
                back: >
                        [$]P = (\\Sigma,s_0,g)[/$], kde [$]\\Sigma=(S,A,\\gamma)[/$]
                        je plánovací doména, [$]s_0[/$] je počáteční stav,
                        [$]g\\subseteq L[/$] jsou cílové výroky.
        -
                uuid: 73c1b436-401f-4cec-bdb8-4f0bf63da074
                topic: STRIPS plánování
                front: Definice - minimální řešení
                back: Plán jehož výsledek splňuje cílové výroky a je takový nejkratší.
        -
                uuid: 4e46e196-cd01-43e9-9234-a49402354757
                topic: STRIPS plánování
                front: Definice - akce je relevantní pro cíl [$]g[/$]
                back: >
                        Když [$]g\\cap eff^+(a)\\neq\\emptyset[/$] a [$]g\\cap eff^-(a)=\\emptyset[/$].
        -
                uuid: da45bb52-8736-4e6d-9754-e7a707678e33
                topic: STRIPS plánování
                front: Definice - regresní množiny
                back: >
                        Pro cíl [$]g[/$] a relevantní akci [$]a[/$]:
                        [$$]\\gamma^{-1}(g,a)=(g-eff^{+}(a))\\cup precond(a)[/$$]
                        [$$]\\Gamma^{-1}(g)=\\{\\gamma^{-1}(g,a) : a\\in A, \\text{relevantni pro}\\ g\\}[/$$]
                        [$$]\\Gamma_\\infty^{-1}(g)=\\Gamma^{-1}(g)\\cup\\Gamma^{-1}(g)\\cup\\ldots[/$$]
        -
                uuid: 80482898-f547-4b91-8b36-f9362c688e06
                topic: STRIPS plánování
                front: Kdy má problém řešení, v řeči regresních množin?
                back: >
                        Když [$]s_0[/$] je nadmnožina nějakého prvku [$]\\Gamma_\\infty^{-1}(g)[/$].
        -
                uuid: 9f3820c7-6ea2-44fc-a98e-b62f77dcaa94
                topic: STRIPS plánování
                front: Klasická reprezentace
                back: >
                        Jazyk: máme relační symboly a konstanty, můžeme používat proměnné.
                        Nemáme funkce. Stav je množina instanciovaných atomů (konečně mnoha).
                        <br>
                        Máme closed world assumption.
        -
                uuid: c5dbfefc-72ce-4476-9110-6b7ff1555875
                topic: STRIPS plánování
                front: Klasická reprezentace - typy atomů podle toho, co dělají
                back: Flexibilní (fluent) se mění, neměnné (rigid) jsou výroky co platí pořád.
        -
                uuid: ecbf6bce-83b9-4d15-acd6-2c7bd62ea698
                topic: STRIPS plánování
                front: Definice - Plánovací operátor a akce
                back: >
                        [$$](name(o), precond(o), effects(o)[/$$]
                        <br>
                        Jméno: symbol a symboly parametrů operátoru ([$]n(x_1,\\ldots x_k)[/$]).
                        <br>
                        Preconditions: pozitivní a negativní atomy.
                        <br>
                        Effects: nesmí být neměnné atomy.
                        <br>
                        Akce je plně instanciovaný operátor.
        -
                uuid: 980e7651-cdb8-4cb9-b435-0e8e879ed6f4
                topic: STRIPS plánování
                front: Notace - pozitivní a negativní atomy v S
                back: >
                        [$$]S^+, S^-[/$$]
        -
                uuid: 12412f4d-9dd1-4855-973f-ca777c25f870
                topic: STRIPS plánování
                front: Kdy je akce použitelná?
                back: Když jsou splněny pozitivní preconditiony a žádný z negativních precondition atomů.
        -
                uuid: 596441a3-8174-41a4-9207-af9eedacabf6
                topic: STRIPS plánování
                front: Rozšíření klasického plánování
                back: >
                        Typované proměnné.<br>
                        Existenčně kvantifikované cíle.<br>
                        Podmíněné operátory ("přepni přepínač" vs. "zapni" a "vypni").<br>
                        Disjunktivní předpoklady (libovolné formule)<br>
                        Připojené procedury (složitější předpoklady operátorů)<br>
                        Logické axiomy (třeba "být vedle je ekvivalence") --
                        musíme rozdělit atomy na primární (jsou v předpokladech i efektech)
                        a sekundární (jen v předpokladech) -- příklad "holding/empty"
        # planovani a rozvrhovani lecture03
        -
                uuid: 54b4e7a1-9e3e-40ac-83a5-9426c4820552
                topic: Plánování
                front: Co by se stalo kdybychom přidali funkční symboly do reprezentace?
                back: Z problému existence plánu by se stal částečně rozhodnutelný problém (byl by z toho halting problém).
        -
                uuid: 7611f49c-dafa-4762-96ec-0ded99c1201c
                topic: Plánování
                front: >
                        Složitost - Negativní efekty? Existence plánu?
                back: >
                        Negativní efekty: existence je EXPSPACE-c, plán do dané délky je NEXPTIME-c.
                        <br>
                        Bez negativních efektů, s negativními předpoklady: existence je NEXPTIME-c, do dané délky je NEXPTIME-c.
                        <br>
                        # TODO: Divne. Nejsou tady ty tridy obracene?
                        Bez negativních efektů a předpokladů: existence je EXPTIME-c, plán do dané délky je NEXPTIME-c.
        -
                uuid: e0e993d1-de4f-40e6-abc7-63183df5f1ca
                topic: Plánování
                front: >
                        Prostory, které při plánování prohledáváme
                back: >
                        Stavový prostor, nebo prostor plánů (uzly jsou částečně instanciované plány).
        -
                uuid: b55b012e-ac6c-45a8-b6db-916c13d7d99a
                topic: Plánování
                front: >
                        Zpětné plánování ve stavovém prostoru a jeho neefektivita
                back: >
                        Začnu od konce.
                        <br>
                        Nedeterministicky zkouším akce, které jsou relevantní
                        k cíli.
                        <br>
                        Neefektivita: není to liftnuté, zbytečně instanciujeme
        -
                uuid: 52bb360d-51fc-4e5f-be01-4896cdda5d12
                topic: Plánování
                front: Algoritmus lifted backward search
                back: >
                        Najdi MGU mezi efekty nějakého operátoru
                        a nějakého atomu, který mám v cíli.
                        <br>
                        Vyber si nedeterministicky a pokračuj.
                        <br>
                        Volné proměnné ztěžují detekci cyklů.
        -
                uuid: 13205a65-48c4-486f-b806-8954fad936a4
                front: Jak STRIPS algoritmus redukuje prostor zpětného plánování?
                back: >
                        Z podcíle řeší vždy jen část odpovídající předpokladům
                        poslední přidané akce.
                        (Tj. místo [$]\\gamma^{-1}(s,a)[/$] použij jako cíl
                        [$]precond(a)[/$].)
                        Kvůli tomu je neúplný.
                        <br>
                        Pokud aktuální stav splňuje všechny předpoklady operátoru,
                        operátor se použije, a při backtrackingu ten závazek
                        nezruším.
        -
                uuid: cbc43b9b-fafe-4437-9400-c6b79caf42f7
                front: Ground-STRIPS algoritmus -- popis
                back: >
                        Začni s prázdným plánem.

                        <br>
                        Nedeterministicky vyber akci, která je relevantní
                        pro cíl.
                        <br>
                        Pokračuj s podcílem [$]precond(a)[/$].
        -
                uuid: e7bd7fec-22e3-4c24-bff7-11c99b16076d
                front: Problémy plánování ve stavovém prostoru a jak je řeší plánování v prostoru plánů
                back: >
                        Velký větvící faktor a spousta alternativních pořadí akcí.
                        <br>
                        Řešení: least commitment -- nerozhoduj co nemusíš rozhodnout teď
        -
                uuid: 336a7bd4-ef38-4070-b831-c06971860289
                front: Sussmanova anomálie
                back: >
                        Svět kostek. Stack 1: (c) nad (a), stack 2: (b).
                        Cíl: (a) nad (b) nad (c).
        # planovani a rozvrhovani lecture04
        -
                uuid: 7a888339-4772-4f9f-8309-e7bb2b722d96
                front: Princip plánování v prostoru plánů
                back: >
                        Začnu v prázdném plánu, co má jenom poč. stav a cíle.
                        Přidáváme akce, co plní otevřené cíle.
                        Přidáváme vazby mezi akcemi.
                        Plánování je opravování kazů, dokud nedostaneme úplný
                        plán.
        -
                uuid: 5a6559f3-1763-4fca-9e8a-50793776ed06
                topic: Plánování v prostoru plánů
                front: Kódování startu a cíle
                back: >
                        Start: akce co nemá předpoklady a je na začátku,
                        cíl: akce co má prázdný efekt a je poslední
        -
                uuid: 717a8985-f6f6-4490-ae19-db6ef0fc506b
                topic: Plánování v prostoru plánů
                front: Uzel prostoru plánů
                back: >
                        Částečný plán: [$]\\Pi=(A,<,B,L)[/$]
                        <br>
                        kde [$]A[/$] jsou částečně instanciované
                        plánovací operátory,
                        <br>
                        [$]<[/$] je část. usp. na [$]A[/$],
                        <br>
                        [$]B[/$] jsou vazby typu [$]x=y[$], [$]x\\neq y[/$]
                        nebo [$]x\\in D_i[/$],
                        <br>
                        [$]L[/$] jsou kauzální vztahy typu [$]a_i \\rightarrow^p a_j[/$]:
                        [$]a_i < a_j[/$] v částečném uspořádání, [$]p[/$] je efekt
                        [$]a_i[/$] a předpoklad [$]a_j[/$], v [$]B[/$] jsou
                        vazby mezi proměnnými v [$]p[/$]
        -
                uuid: dedc413d-63ec-41b1-a1ca-739e3245de10
                topic: Plánování v prostoru plánů
                front: Otevřený cíl a jak se dá řešit
                back: >
                        Je to předpoklad [$]p[/$] operátoru [$]b[/$],
                        na který ještě neexistuje kauzální vazba.<br>
                        Odstranění:
                        <ol>
                        <li>Najdi operátor (buď přítomný v plánu nebo nový),
                                co se dá použít na splnění [$]p[/$]
                                (tj. [$]p[/$] je efekt a může být před [$]b[/$]).
                        <li>Svaž proměnné
                        <li>Vytvoř kauzální vazbu
                        </ol>
        -
                uuid: bd7b1a12-8410-49f3-9f1b-b9c21917059b
                topic: Plánování v prostoru plánů
                front: Hrozba - co to je, jak ji vyřešit
                back: >
                        Hrozba je akce, co může porušit kauzální vazbu:
                        [$]a_i\\rightarrow^p a_j[/$] je vazba
                        a akce [$]b[/$] je unifikovatelná s negací [$]p[/$]
                        a může být v [$]<[/$] mezi [$]a_i[/$] a [$]a_j[/$].
                        <br>
                        Tři možné způsoby:
                        <ul>
                        <li>[$]b<a_i[/$]
                        <li>[$]b>a_j[/$]
                        <li>Navázání proměnných v [$]b[/$], aby nerušily platnost [$]p[/$]
                        </ul>
        -
                uuid: cbd24fa0-e675-4896-aeba-602d3c411f84
                topic: Plánování v prostoru plánů
                front: Kdy je částečný plán řešící plán?
                back: >
                        Když má globálně konzistentní vazby [$]a=b/a\\neq b/a\\in D_i[/$],
                        konzistentní uspořádání [$]<[/$].
                        <br>
                        To je ekvivalentní tomu, když nemá kazy (tj. otevř. cíle a hrozby)
                        a vazby [$]B[/$] a [$]<[/$] jsou glob. konzistentní.
                        Důkaz indukcí.
        -
                uuid: 0e25a3ad-82ec-4fbe-ba5e-b497e02ad876
                topic: Plánování v prostoru plánů
                front: Detaily algoritmu PSP -- časy na hledání hrozeb, konzistence, agenda
                back: >
                        Agenda předpokladů akcí: když přidám kauzální vazbu pro něco, odeberu to z agendy.
                        <br>
                        Hrozby: nalezení po trojicích akcí ([$]\\O(n^3)[/$]),
                        lépe: po přidání akce zjisti komu hrozí ([$]\\O(n^2)[/$]),
                        po přidání kauzální vazby ověř její hrozby ([$]\\O(n)[/$]).
                        <br>
                        Pro odstrańování kazů používej jenom konzistentní zjemnění plánu.
                        Udržuj tranzitivní uzávěr [$]<[/$] nebo detekuj cykly.
                        Konzistence vztahů [$]B[/$]: když nemám negaci, stačí AC.
                        Když mám negaci, je to NP-úplné :/
        -
                uuid: 3f1ea7e9-42b0-403f-8fd0-5d7e20c18ac8
                topic: Plánování v prostoru plánů
                front: Korektnost, úplnost, konečnost
                back: >
                        Korektnost: pokud skončí, tak vydá dobrý plán.<br>
                        Pokud existuje plán, vrátí ho.<br>
                        Pozor: prostor plánů není konečný! Je potřeba např.
                        iterative deepening.
        # TODO planovani a rozvrhovani lecture05
